(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/compiler'), require('@angular/compiler-cli'), require('@angular/compiler-cli/ngtools2'), require('typescript'), require('@angular/compiler-cli/src/transformers/compiler_host')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/compiler', '@angular/compiler-cli', '@angular/compiler-cli/ngtools2', 'typescript', '@angular/compiler-cli/src/transformers/compiler_host'], factory) :
	(factory((global.ngast = global.ngast || {}),global._angular_core,global._angular_compiler,global._angular_compilerCli,global._angular_compilerCli_ngtools2,global.ts,global._angular_compilerCli_src_transformers_compiler_host));
}(this, (function (exports,_angular_core,_angular_compiler,_angular_compilerCli,_angular_compilerCli_ngtools2,ts,_angular_compilerCli_src_transformers_compiler_host) { 'use strict';

/**
 * Base class which provides primitive for the DirectiveSymbol and
 * PipeSymbol. It contains some functionality common between these classes.
 *
 * @export
 * @class Symbol
 */
var Symbol = /** @class */ (function () {
    /**
     * Creates an instance of Symbol.
     *
     * @param {ts.Program} _program
     * @param {StaticSymbol} _symbol
     *
     * @memberOf Symbol
     */
    function Symbol(_program, _symbol) {
        this._program = _program;
        this._symbol = _symbol;
    }
    /**
     * Gets the ts.node which corresponds to the controller of the DirectiveSymbol
     * or the implementation of the pipe.
     *
     * @returns {(ts.ClassDeclaration | undefined)}
     *
     * @memberOf Symbol
     */
    Symbol.prototype.getNode = function () {
        var _this = this;
        var program = this._program.getSourceFile(this._symbol.filePath);
        var findNode = function (node) {
            if (node.kind === ts.SyntaxKind.ClassDeclaration &&
                (node.name || { text: undefined }).text === _this._symbol.name) {
                return node;
            }
            else {
                return ts.forEachChild(node, findNode);
            }
        };
        return findNode(program);
    };
    Object.defineProperty(Symbol.prototype, "symbol", {
        /**
         * The wrapped `StaticSymbol` from `@angular/compiler`.
         *
         * @readonly
         *
         * @memberOf Symbol
         */
        get: function () {
            return this._symbol;
        },
        enumerable: true,
        configurable: true
    });
    return Symbol;
}());

var ProviderSymbol = /** @class */ (function () {
    function ProviderSymbol(program, provider, metadataResolver) {
        this.program = program;
        this.provider = provider;
        this.metadataResolver = metadataResolver;
    }
    /**
     * Returns the provider metadata.
     */
    ProviderSymbol.prototype.getMetadata = function () {
        return this.provider;
    };
    /**
     * Returns the list of dependencies for given provider.
     */
    ProviderSymbol.prototype.getDependencies = function () {
        var _this = this;
        return (this.provider.deps || []).map(function (d) {
            var token = d.token;
            if (d.token) {
                if (d.token.identifier) {
                    token = d.token.identifier.reference;
                }
            }
            var meta = new _angular_compiler.ProviderMeta(token, { useClass: d.value });
            return new ProviderSymbol(_this.program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
        });
    };
    return ProviderSymbol;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * A wrapper around the pipe symbol.
 *
 * @export
 * @class PipeSymbol
 * @extends {Symbol}
 */
var PipeSymbol = /** @class */ (function (_super) {
    __extends(PipeSymbol, _super);
    /**
     * Creates an instance of PipeSymbol.
     *
     * @param {Program} program
     * @param {StaticSymbol} symbol
     * @param {PipeResolver} resolver
     * @param {ContextSymbols} projectSymbols
     *
     * @memberOf PipeSymbol
     */
    function PipeSymbol(program, symbol, resolver, metadataResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.resolver = resolver;
        _this.metadataResolver = metadataResolver;
        _this.projectSymbols = projectSymbols;
        return _this;
    }
    /**
     * Returns the module where the wrapped pipe was defined.
     *
     * @returns {(CompileNgModuleMetadata | undefined)}
     *
     * @memberOf PipeSymbol
     */
    PipeSymbol.prototype.getModule = function () {
        return this.projectSymbols.getAnalyzedModules().ngModuleByPipeOrDirective.get(this.symbol);
    };
    /**
     * Returns the pipe metadata.
     *
     * @returns {Pipe}
     *
     * @memberOf PipeSymbol
     */
    PipeSymbol.prototype.getMetadata = function () {
        return this.resolver.resolve(_angular_core.resolveForwardRef(this.symbol));
    };
    PipeSymbol.prototype.getDependencies = function () {
        var _this = this;
        var summary = this.metadataResolver.getInjectableSummary(this.symbol);
        if (!summary) {
            return [];
        }
        else {
            return (summary.type.diDeps || []).map(function (d) {
                var token = d.token;
                if (d.token) {
                    if (d.token.identifier) {
                        token = d.token.identifier.reference;
                    }
                }
                var meta = new _angular_compiler.ProviderMeta(token, { useClass: d.value });
                return new ProviderSymbol(_this._program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
            });
        }
    };
    return PipeSymbol;
}(Symbol));

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var $EOF = 0;
var $TAB = 9;
var $LF = 10;
var $VTAB = 11;
var $FF = 12;
var $CR = 13;
var $SPACE = 32;
var $BANG = 33;
var $DQ = 34;
var $HASH = 35;
var $$ = 36;
var $PERCENT = 37;
var $AMPERSAND = 38;
var $SQ = 39;
var $LPAREN = 40;
var $RPAREN = 41;
var $STAR = 42;
var $PLUS = 43;
var $COMMA = 44;
var $MINUS = 45;
var $PERIOD = 46;
var $SLASH = 47;
var $COLON = 58;
var $SEMICOLON = 59;

var $EQ = 61;
var $GT = 62;
var $QUESTION = 63;
var $0 = 48;
var $9 = 57;
var $A = 65;



var $Z = 90;
var $LBRACKET = 91;
var $BACKSLASH = 92;
var $RBRACKET = 93;
var $CARET = 94;
var $_ = 95;
var $a = 97;








var $z = 122;
var $LBRACE = 123;

var $RBRACE = 125;
var $NBSP = 160;
var $PIPE = 124;
var $TILDA = 126;
var $AT = 64;

function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
}
function isDigit(code) {
    return $0 <= code && code <= $9;
}
function isAsciiLetter(code) {
    return code >= $a && code <= $z || code >= $A && code <= $Z;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var ParseLocation = /** @class */ (function () {
    function ParseLocation(file, offset, line, col) {
        this.file = file;
        this.offset = offset;
        this.line = line;
        this.col = col;
    }
    ParseLocation.prototype.toString = function () {
        return this.offset != null ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
    };
    ParseLocation.prototype.moveBy = function (delta) {
        var source = this.file.content;
        var len = source.length;
        var offset = this.offset;
        var line = this.line;
        var col = this.col;
        while (offset > 0 && delta < 0) {
            offset--;
            delta++;
            var ch = source.charCodeAt(offset);
            if (ch == $LF) {
                line--;
                var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
                col = priorLine > 0 ? offset - priorLine : offset;
            }
            else {
                col--;
            }
        }
        while (offset < len && delta > 0) {
            var ch = source.charCodeAt(offset);
            offset++;
            delta--;
            if (ch == $LF) {
                line++;
                col = 0;
            }
            else {
                col++;
            }
        }
        return new ParseLocation(this.file, offset, line, col);
    };
    // Return the source around the location
    // Up to `maxChars` or `maxLines` on each side of the location
    ParseLocation.prototype.getContext = function (maxChars, maxLines) {
        var content = this.file.content;
        var startOffset = this.offset;
        if (startOffset != null) {
            if (startOffset > content.length - 1) {
                startOffset = content.length - 1;
            }
            var endOffset = startOffset;
            var ctxChars = 0;
            var ctxLines = 0;
            while (ctxChars < maxChars && startOffset > 0) {
                startOffset--;
                ctxChars++;
                if (content[startOffset] == '\n') {
                    if (++ctxLines == maxLines) {
                        break;
                    }
                }
            }
            ctxChars = 0;
            ctxLines = 0;
            while (ctxChars < maxChars && endOffset < content.length - 1) {
                endOffset++;
                ctxChars++;
                if (content[endOffset] == '\n') {
                    if (++ctxLines == maxLines) {
                        break;
                    }
                }
            }
            return {
                before: content.substring(startOffset, this.offset),
                after: content.substring(this.offset, endOffset + 1),
            };
        }
        return null;
    };
    return ParseLocation;
}());
var ParseSourceFile = /** @class */ (function () {
    function ParseSourceFile(content, url) {
        this.content = content;
        this.url = url;
    }
    return ParseSourceFile;
}());
var ParseSourceSpan = /** @class */ (function () {
    function ParseSourceSpan(start, end, details) {
        if (details === void 0) { details = null; }
        this.start = start;
        this.end = end;
        this.details = details;
    }
    ParseSourceSpan.prototype.toString = function () {
        return this.start.file.content.substring(this.start.offset, this.end.offset);
    };
    return ParseSourceSpan;
}());
var ParseErrorLevel;
(function (ParseErrorLevel) {
    ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
    ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
})(ParseErrorLevel || (ParseErrorLevel = {}));
var ParseError = /** @class */ (function () {
    function ParseError(span, msg, level) {
        if (level === void 0) { level = ParseErrorLevel.ERROR; }
        this.span = span;
        this.msg = msg;
        this.level = level;
    }
    ParseError.prototype.toString = function () {
        var ctx = this.span.start.getContext(100, 3);
        var contextStr = ctx ? " (\"" + ctx.before + "[" + ParseErrorLevel[this.level] + " ->]" + ctx.after + "\")" : '';
        var details = this.span.details ? ", " + this.span.details : '';
        return "" + this.msg + contextStr + ": " + this.span.start + details;
    };
    return ParseError;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var CssTokenType;
(function (CssTokenType) {
    CssTokenType[CssTokenType["EOF"] = 0] = "EOF";
    CssTokenType[CssTokenType["String"] = 1] = "String";
    CssTokenType[CssTokenType["Comment"] = 2] = "Comment";
    CssTokenType[CssTokenType["Identifier"] = 3] = "Identifier";
    CssTokenType[CssTokenType["Number"] = 4] = "Number";
    CssTokenType[CssTokenType["IdentifierOrNumber"] = 5] = "IdentifierOrNumber";
    CssTokenType[CssTokenType["AtKeyword"] = 6] = "AtKeyword";
    CssTokenType[CssTokenType["Character"] = 7] = "Character";
    CssTokenType[CssTokenType["Whitespace"] = 8] = "Whitespace";
    CssTokenType[CssTokenType["Invalid"] = 9] = "Invalid";
})(CssTokenType || (CssTokenType = {}));
var CssLexerMode;
(function (CssLexerMode) {
    CssLexerMode[CssLexerMode["ALL"] = 0] = "ALL";
    CssLexerMode[CssLexerMode["ALL_TRACK_WS"] = 1] = "ALL_TRACK_WS";
    CssLexerMode[CssLexerMode["SELECTOR"] = 2] = "SELECTOR";
    CssLexerMode[CssLexerMode["PSEUDO_SELECTOR"] = 3] = "PSEUDO_SELECTOR";
    CssLexerMode[CssLexerMode["PSEUDO_SELECTOR_WITH_ARGUMENTS"] = 4] = "PSEUDO_SELECTOR_WITH_ARGUMENTS";
    CssLexerMode[CssLexerMode["ATTRIBUTE_SELECTOR"] = 5] = "ATTRIBUTE_SELECTOR";
    CssLexerMode[CssLexerMode["AT_RULE_QUERY"] = 6] = "AT_RULE_QUERY";
    CssLexerMode[CssLexerMode["MEDIA_QUERY"] = 7] = "MEDIA_QUERY";
    CssLexerMode[CssLexerMode["BLOCK"] = 8] = "BLOCK";
    CssLexerMode[CssLexerMode["KEYFRAME_BLOCK"] = 9] = "KEYFRAME_BLOCK";
    CssLexerMode[CssLexerMode["STYLE_BLOCK"] = 10] = "STYLE_BLOCK";
    CssLexerMode[CssLexerMode["STYLE_VALUE"] = 11] = "STYLE_VALUE";
    CssLexerMode[CssLexerMode["STYLE_VALUE_FUNCTION"] = 12] = "STYLE_VALUE_FUNCTION";
    CssLexerMode[CssLexerMode["STYLE_CALC_FUNCTION"] = 13] = "STYLE_CALC_FUNCTION";
})(CssLexerMode || (CssLexerMode = {}));
var LexedCssResult = /** @class */ (function () {
    function LexedCssResult(error, token) {
        this.error = error;
        this.token = token;
    }
    return LexedCssResult;
}());
function generateErrorMessage(input, message, errorValue, index, row, column) {
    return message + " at column " + row + ":" + column + " in expression [" +
        findProblemCode(input, errorValue, index, column) + ']';
}
function findProblemCode(input, errorValue, index, column) {
    var endOfProblemLine = index;
    var current = charCode(input, index);
    while (current > 0 && !isNewline(current)) {
        current = charCode(input, ++endOfProblemLine);
    }
    var choppedString = input.substring(0, endOfProblemLine);
    var pointerPadding = '';
    for (var i = 0; i < column; i++) {
        pointerPadding += ' ';
    }
    var pointerString = '';
    for (var i = 0; i < errorValue.length; i++) {
        pointerString += '^';
    }
    return choppedString + '\n' + pointerPadding + pointerString + '\n';
}
var CssToken = /** @class */ (function () {
    function CssToken(index, column, line, type, strValue) {
        this.index = index;
        this.column = column;
        this.line = line;
        this.type = type;
        this.strValue = strValue;
        this.numValue = charCode(strValue, 0);
    }
    return CssToken;
}());
var CssLexer = /** @class */ (function () {
    function CssLexer() {
    }
    CssLexer.prototype.scan = function (text, trackComments) {
        if (trackComments === void 0) { trackComments = false; }
        return new CssScanner(text, trackComments);
    };
    return CssLexer;
}());
function cssScannerError(token, message) {
    var error = Error('CssParseError: ' + message);
    error[ERROR_RAW_MESSAGE] = message;
    error[ERROR_TOKEN] = token;
    return error;
}
var ERROR_TOKEN = 'ngToken';
var ERROR_RAW_MESSAGE = 'ngRawMessage';
function getRawMessage(error) {
    return error[ERROR_RAW_MESSAGE];
}

function _trackWhitespace(mode) {
    switch (mode) {
        case CssLexerMode.SELECTOR:
        case CssLexerMode.PSEUDO_SELECTOR:
        case CssLexerMode.ALL_TRACK_WS:
        case CssLexerMode.STYLE_VALUE:
            return true;
        default:
            return false;
    }
}
var CssScanner = /** @class */ (function () {
    function CssScanner(input, _trackComments) {
        if (_trackComments === void 0) { _trackComments = false; }
        this.input = input;
        this._trackComments = _trackComments;
        this.length = 0;
        this.index = -1;
        this.column = -1;
        this.line = 0;
        /** @internal */
        this._currentMode = CssLexerMode.BLOCK;
        /** @internal */
        this._currentError = null;
        this.length = this.input.length;
        this.peekPeek = this.peekAt(0);
        this.advance();
    }
    CssScanner.prototype.getMode = function () { return this._currentMode; };
    CssScanner.prototype.setMode = function (mode) {
        if (this._currentMode != mode) {
            if (_trackWhitespace(this._currentMode) && !_trackWhitespace(mode)) {
                this.consumeWhitespace();
            }
            this._currentMode = mode;
        }
    };
    CssScanner.prototype.advance = function () {
        if (isNewline(this.peek)) {
            this.column = 0;
            this.line++;
        }
        else {
            this.column++;
        }
        this.index++;
        this.peek = this.peekPeek;
        this.peekPeek = this.peekAt(this.index + 1);
    };
    CssScanner.prototype.peekAt = function (index) {
        return index >= this.length ? $EOF : this.input.charCodeAt(index);
    };
    CssScanner.prototype.consumeEmptyStatements = function () {
        this.consumeWhitespace();
        while (this.peek == $SEMICOLON) {
            this.advance();
            this.consumeWhitespace();
        }
    };
    CssScanner.prototype.consumeWhitespace = function () {
        while (isWhitespace(this.peek) || isNewline(this.peek)) {
            this.advance();
            if (!this._trackComments && isCommentStart(this.peek, this.peekPeek)) {
                this.advance(); // /
                this.advance(); // *
                while (!isCommentEnd(this.peek, this.peekPeek)) {
                    if (this.peek == $EOF) {
                        this.error('Unterminated comment');
                    }
                    this.advance();
                }
                this.advance(); // *
                this.advance(); // /
            }
        }
    };
    CssScanner.prototype.consume = function (type, value) {
        if (value === void 0) { value = null; }
        var mode = this._currentMode;
        this.setMode(_trackWhitespace(mode) ? CssLexerMode.ALL_TRACK_WS : CssLexerMode.ALL);
        var previousIndex = this.index;
        var previousLine = this.line;
        var previousColumn = this.column;
        var next = undefined;
        var output = this.scan();
        if (output != null) {
            // just incase the inner scan method returned an error
            if (output.error != null) {
                this.setMode(mode);
                return output;
            }
            next = output.token;
        }
        if (next == null) {
            next = new CssToken(this.index, this.column, this.line, CssTokenType.EOF, 'end of file');
        }
        var isMatchingType = false;
        if (type == CssTokenType.IdentifierOrNumber) {
            // TODO (matsko): implement array traversal for lookup here
            isMatchingType = next.type == CssTokenType.Number || next.type == CssTokenType.Identifier;
        }
        else {
            isMatchingType = next.type == type;
        }
        // before throwing the error we need to bring back the former
        // mode so that the parser can recover...
        this.setMode(mode);
        var error = null;
        if (!isMatchingType || (value != null && value != next.strValue)) {
            var errorMessage = CssTokenType[next.type] + ' does not match expected ' + CssTokenType[type] + ' value';
            if (value != null) {
                errorMessage += ' ("' + next.strValue + '" should match "' + value + '")';
            }
            error = cssScannerError(next, generateErrorMessage(this.input, errorMessage, next.strValue, previousIndex, previousLine, previousColumn));
        }
        return new LexedCssResult(error, next);
    };
    CssScanner.prototype.scan = function () {
        var trackWS = _trackWhitespace(this._currentMode);
        if (this.index == 0 && !trackWS) {
            this.consumeWhitespace();
        }
        var token = this._scan();
        if (token == null)
            return null;
        var error = this._currentError;
        this._currentError = null;
        if (!trackWS) {
            this.consumeWhitespace();
        }
        return new LexedCssResult(error, token);
    };
    /** @internal */
    CssScanner.prototype._scan = function () {
        var peek = this.peek;
        var peekPeek = this.peekPeek;
        if (peek == $EOF)
            return null;
        if (isCommentStart(peek, peekPeek)) {
            // even if comments are not tracked we still lex the
            // comment so we can move the pointer forward
            var commentToken = this.scanComment();
            if (this._trackComments) {
                return commentToken;
            }
        }
        if (_trackWhitespace(this._currentMode) && (isWhitespace(peek) || isNewline(peek))) {
            return this.scanWhitespace();
        }
        peek = this.peek;
        peekPeek = this.peekPeek;
        if (peek == $EOF)
            return null;
        if (isStringStart(peek, peekPeek)) {
            return this.scanString();
        }
        // something like url(cool)
        if (this._currentMode == CssLexerMode.STYLE_VALUE_FUNCTION) {
            return this.scanCssValueFunction();
        }
        var isModifier = peek == $PLUS || peek == $MINUS;
        var digitA = isModifier ? false : isDigit(peek);
        var digitB = isDigit(peekPeek);
        if (digitA || (isModifier && (peekPeek == $PERIOD || digitB)) ||
            (peek == $PERIOD && digitB)) {
            return this.scanNumber();
        }
        if (peek == $AT) {
            return this.scanAtExpression();
        }
        if (isIdentifierStart(peek, peekPeek)) {
            return this.scanIdentifier();
        }
        if (isValidCssCharacter(peek, this._currentMode)) {
            return this.scanCharacter();
        }
        return this.error("Unexpected character [" + String.fromCharCode(peek) + "]");
    };
    CssScanner.prototype.scanComment = function () {
        if (this.assertCondition(isCommentStart(this.peek, this.peekPeek), 'Expected comment start value')) {
            return null;
        }
        var start = this.index;
        var startingColumn = this.column;
        var startingLine = this.line;
        this.advance(); // /
        this.advance(); // *
        while (!isCommentEnd(this.peek, this.peekPeek)) {
            if (this.peek == $EOF) {
                this.error('Unterminated comment');
            }
            this.advance();
        }
        this.advance(); // *
        this.advance(); // /
        var str = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, startingLine, CssTokenType.Comment, str);
    };
    CssScanner.prototype.scanWhitespace = function () {
        var start = this.index;
        var startingColumn = this.column;
        var startingLine = this.line;
        while (isWhitespace(this.peek) && this.peek != $EOF) {
            this.advance();
        }
        var str = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, startingLine, CssTokenType.Whitespace, str);
    };
    CssScanner.prototype.scanString = function () {
        if (this.assertCondition(isStringStart(this.peek, this.peekPeek), 'Unexpected non-string starting value')) {
            return null;
        }
        var target = this.peek;
        var start = this.index;
        var startingColumn = this.column;
        var startingLine = this.line;
        var previous = target;
        this.advance();
        while (!isCharMatch(target, previous, this.peek)) {
            if (this.peek == $EOF || isNewline(this.peek)) {
                this.error('Unterminated quote');
            }
            previous = this.peek;
            this.advance();
        }
        if (this.assertCondition(this.peek == target, 'Unterminated quote')) {
            return null;
        }
        this.advance();
        var str = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, startingLine, CssTokenType.String, str);
    };
    CssScanner.prototype.scanNumber = function () {
        var start = this.index;
        var startingColumn = this.column;
        if (this.peek == $PLUS || this.peek == $MINUS) {
            this.advance();
        }
        var periodUsed = false;
        while (isDigit(this.peek) || this.peek == $PERIOD) {
            if (this.peek == $PERIOD) {
                if (periodUsed) {
                    this.error('Unexpected use of a second period value');
                }
                periodUsed = true;
            }
            this.advance();
        }
        var strValue = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, this.line, CssTokenType.Number, strValue);
    };
    CssScanner.prototype.scanIdentifier = function () {
        if (this.assertCondition(isIdentifierStart(this.peek, this.peekPeek), 'Expected identifier starting value')) {
            return null;
        }
        var start = this.index;
        var startingColumn = this.column;
        while (isIdentifierPart(this.peek)) {
            this.advance();
        }
        var strValue = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);
    };
    CssScanner.prototype.scanCssValueFunction = function () {
        var start = this.index;
        var startingColumn = this.column;
        var parenBalance = 1;
        while (this.peek != $EOF && parenBalance > 0) {
            this.advance();
            if (this.peek == $LPAREN) {
                parenBalance++;
            }
            else if (this.peek == $RPAREN) {
                parenBalance--;
            }
        }
        var strValue = this.input.substring(start, this.index);
        return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);
    };
    CssScanner.prototype.scanCharacter = function () {
        var start = this.index;
        var startingColumn = this.column;
        if (this.assertCondition(isValidCssCharacter(this.peek, this._currentMode), charStr(this.peek) + ' is not a valid CSS character')) {
            return null;
        }
        var c = this.input.substring(start, start + 1);
        this.advance();
        return new CssToken(start, startingColumn, this.line, CssTokenType.Character, c);
    };
    CssScanner.prototype.scanAtExpression = function () {
        if (this.assertCondition(this.peek == $AT, 'Expected @ value')) {
            return null;
        }
        var start = this.index;
        var startingColumn = this.column;
        this.advance();
        if (isIdentifierStart(this.peek, this.peekPeek)) {
            var ident = this.scanIdentifier();
            var strValue = '@' + ident.strValue;
            return new CssToken(start, startingColumn, this.line, CssTokenType.AtKeyword, strValue);
        }
        else {
            return this.scanCharacter();
        }
    };
    CssScanner.prototype.assertCondition = function (status, errorMessage) {
        if (!status) {
            this.error(errorMessage);
            return true;
        }
        return false;
    };
    CssScanner.prototype.error = function (message, errorTokenValue, doNotAdvance) {
        if (errorTokenValue === void 0) { errorTokenValue = null; }
        if (doNotAdvance === void 0) { doNotAdvance = false; }
        var index = this.index;
        var column = this.column;
        var line = this.line;
        errorTokenValue = errorTokenValue || String.fromCharCode(this.peek);
        var invalidToken = new CssToken(index, column, line, CssTokenType.Invalid, errorTokenValue);
        var errorMessage = generateErrorMessage(this.input, message, errorTokenValue, index, line, column);
        if (!doNotAdvance) {
            this.advance();
        }
        this._currentError = cssScannerError(invalidToken, errorMessage);
        return invalidToken;
    };
    return CssScanner;
}());
function isCharMatch(target, previous, code) {
    return code == target && previous != $BACKSLASH;
}
function isCommentStart(code, next) {
    return code == $SLASH && next == $STAR;
}
function isCommentEnd(code, next) {
    return code == $STAR && next == $SLASH;
}
function isStringStart(code, next) {
    var target = code;
    if (target == $BACKSLASH) {
        target = next;
    }
    return target == $DQ || target == $SQ;
}
function isIdentifierStart(code, next) {
    var target = code;
    if (target == $MINUS) {
        target = next;
    }
    return isAsciiLetter(target) || target == $BACKSLASH || target == $MINUS ||
        target == $_;
}
function isIdentifierPart(target) {
    return isAsciiLetter(target) || target == $BACKSLASH || target == $MINUS ||
        target == $_ || isDigit(target);
}
function isValidPseudoSelectorCharacter(code) {
    switch (code) {
        case $LPAREN:
        case $RPAREN:
            return true;
        default:
            return false;
    }
}
function isValidKeyframeBlockCharacter(code) {
    return code == $PERCENT;
}
function isValidAttributeSelectorCharacter(code) {
    // value^*|$~=something
    switch (code) {
        case $$:
        case $PIPE:
        case $CARET:
        case $TILDA:
        case $STAR:
        case $EQ:
            return true;
        default:
            return false;
    }
}
function isValidSelectorCharacter(code) {
    // selector [ key   = value ]
    // IDENT    C IDENT C IDENT C
    // #id, .class, *+~>
    // tag:PSEUDO
    switch (code) {
        case $HASH:
        case $PERIOD:
        case $TILDA:
        case $STAR:
        case $PLUS:
        case $GT:
        case $COLON:
        case $PIPE:
        case $COMMA:
        case $LBRACKET:
        case $RBRACKET:
            return true;
        default:
            return false;
    }
}
function isValidStyleBlockCharacter(code) {
    // key:value;
    // key:calc(something ... )
    switch (code) {
        case $HASH:
        case $SEMICOLON:
        case $COLON:
        case $PERCENT:
        case $SLASH:
        case $BACKSLASH:
        case $BANG:
        case $PERIOD:
        case $LPAREN:
        case $RPAREN:
            return true;
        default:
            return false;
    }
}
function isValidMediaQueryRuleCharacter(code) {
    // (min-width: 7.5em) and (orientation: landscape)
    switch (code) {
        case $LPAREN:
        case $RPAREN:
        case $COLON:
        case $PERCENT:
        case $PERIOD:
            return true;
        default:
            return false;
    }
}
function isValidAtRuleCharacter(code) {
    // @document url(http://www.w3.org/page?something=on#hash),
    switch (code) {
        case $LPAREN:
        case $RPAREN:
        case $COLON:
        case $PERCENT:
        case $PERIOD:
        case $SLASH:
        case $BACKSLASH:
        case $HASH:
        case $EQ:
        case $QUESTION:
        case $AMPERSAND:
        case $STAR:
        case $COMMA:
        case $MINUS:
        case $PLUS:
            return true;
        default:
            return false;
    }
}
function isValidStyleFunctionCharacter(code) {
    switch (code) {
        case $PERIOD:
        case $MINUS:
        case $PLUS:
        case $STAR:
        case $SLASH:
        case $LPAREN:
        case $RPAREN:
        case $COMMA:
            return true;
        default:
            return false;
    }
}
function isValidBlockCharacter(code) {
    // @something { }
    // IDENT
    return code == $AT;
}
function isValidCssCharacter(code, mode) {
    switch (mode) {
        case CssLexerMode.ALL:
        case CssLexerMode.ALL_TRACK_WS:
            return true;
        case CssLexerMode.SELECTOR:
            return isValidSelectorCharacter(code);
        case CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS:
            return isValidPseudoSelectorCharacter(code);
        case CssLexerMode.ATTRIBUTE_SELECTOR:
            return isValidAttributeSelectorCharacter(code);
        case CssLexerMode.MEDIA_QUERY:
            return isValidMediaQueryRuleCharacter(code);
        case CssLexerMode.AT_RULE_QUERY:
            return isValidAtRuleCharacter(code);
        case CssLexerMode.KEYFRAME_BLOCK:
            return isValidKeyframeBlockCharacter(code);
        case CssLexerMode.STYLE_BLOCK:
        case CssLexerMode.STYLE_VALUE:
            return isValidStyleBlockCharacter(code);
        case CssLexerMode.STYLE_CALC_FUNCTION:
            return isValidStyleFunctionCharacter(code);
        case CssLexerMode.BLOCK:
            return isValidBlockCharacter(code);
        default:
            return false;
    }
}
function charCode(input, index) {
    return index >= input.length ? $EOF : input.charCodeAt(index);
}
function charStr(code) {
    return String.fromCharCode(code);
}
function isNewline(code) {
    switch (code) {
        case $FF:
        case $CR:
        case $LF:
        case $VTAB:
            return true;
        default:
            return false;
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BlockType;
(function (BlockType) {
    BlockType[BlockType["Import"] = 0] = "Import";
    BlockType[BlockType["Charset"] = 1] = "Charset";
    BlockType[BlockType["Namespace"] = 2] = "Namespace";
    BlockType[BlockType["Supports"] = 3] = "Supports";
    BlockType[BlockType["Keyframes"] = 4] = "Keyframes";
    BlockType[BlockType["MediaQuery"] = 5] = "MediaQuery";
    BlockType[BlockType["Selector"] = 6] = "Selector";
    BlockType[BlockType["FontFace"] = 7] = "FontFace";
    BlockType[BlockType["Page"] = 8] = "Page";
    BlockType[BlockType["Document"] = 9] = "Document";
    BlockType[BlockType["Viewport"] = 10] = "Viewport";
    BlockType[BlockType["Unsupported"] = 11] = "Unsupported";
})(BlockType || (BlockType = {}));
var CssAst = /** @class */ (function () {
    function CssAst(location) {
        this.location = location;
    }
    Object.defineProperty(CssAst.prototype, "start", {
        get: function () { return this.location.start; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CssAst.prototype, "end", {
        get: function () { return this.location.end; },
        enumerable: true,
        configurable: true
    });
    return CssAst;
}());
var CssStyleValueAst = /** @class */ (function (_super) {
    __extends$3(CssStyleValueAst, _super);
    function CssStyleValueAst(location, tokens, strValue) {
        var _this = _super.call(this, location) || this;
        _this.tokens = tokens;
        _this.strValue = strValue;
        return _this;
    }
    CssStyleValueAst.prototype.visit = function (visitor, context) { return visitor.visitCssValue(this); };
    return CssStyleValueAst;
}(CssAst));
var CssRuleAst = /** @class */ (function (_super) {
    __extends$3(CssRuleAst, _super);
    function CssRuleAst(location) {
        return _super.call(this, location) || this;
    }
    return CssRuleAst;
}(CssAst));
var CssBlockRuleAst = /** @class */ (function (_super) {
    __extends$3(CssBlockRuleAst, _super);
    function CssBlockRuleAst(location, type, block, name) {
        if (name === void 0) { name = null; }
        var _this = _super.call(this, location) || this;
        _this.location = location;
        _this.type = type;
        _this.block = block;
        _this.name = name;
        return _this;
    }
    CssBlockRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssBlock(this.block, context);
    };
    return CssBlockRuleAst;
}(CssRuleAst));
var CssKeyframeRuleAst = /** @class */ (function (_super) {
    __extends$3(CssKeyframeRuleAst, _super);
    function CssKeyframeRuleAst(location, name, block) {
        return _super.call(this, location, BlockType.Keyframes, block, name) || this;
    }
    CssKeyframeRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssKeyframeRule(this, context);
    };
    return CssKeyframeRuleAst;
}(CssBlockRuleAst));
var CssKeyframeDefinitionAst = /** @class */ (function (_super) {
    __extends$3(CssKeyframeDefinitionAst, _super);
    function CssKeyframeDefinitionAst(location, steps, block) {
        var _this = _super.call(this, location, BlockType.Keyframes, block, mergeTokens(steps, ',')) || this;
        _this.steps = steps;
        return _this;
    }
    CssKeyframeDefinitionAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssKeyframeDefinition(this, context);
    };
    return CssKeyframeDefinitionAst;
}(CssBlockRuleAst));
var CssBlockDefinitionRuleAst = /** @class */ (function (_super) {
    __extends$3(CssBlockDefinitionRuleAst, _super);
    function CssBlockDefinitionRuleAst(location, strValue, type, query, block) {
        var _this = _super.call(this, location, type, block) || this;
        _this.strValue = strValue;
        _this.query = query;
        var firstCssToken = query.tokens[0];
        _this.name = new CssToken(firstCssToken.index, firstCssToken.column, firstCssToken.line, CssTokenType.Identifier, _this.strValue);
        return _this;
    }
    CssBlockDefinitionRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssBlock(this.block, context);
    };
    return CssBlockDefinitionRuleAst;
}(CssBlockRuleAst));
var CssMediaQueryRuleAst = /** @class */ (function (_super) {
    __extends$3(CssMediaQueryRuleAst, _super);
    function CssMediaQueryRuleAst(location, strValue, query, block) {
        return _super.call(this, location, strValue, BlockType.MediaQuery, query, block) || this;
    }
    CssMediaQueryRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssMediaQueryRule(this, context);
    };
    return CssMediaQueryRuleAst;
}(CssBlockDefinitionRuleAst));
var CssAtRulePredicateAst = /** @class */ (function (_super) {
    __extends$3(CssAtRulePredicateAst, _super);
    function CssAtRulePredicateAst(location, strValue, tokens) {
        var _this = _super.call(this, location) || this;
        _this.strValue = strValue;
        _this.tokens = tokens;
        return _this;
    }
    CssAtRulePredicateAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssAtRulePredicate(this, context);
    };
    return CssAtRulePredicateAst;
}(CssAst));
var CssInlineRuleAst = /** @class */ (function (_super) {
    __extends$3(CssInlineRuleAst, _super);
    function CssInlineRuleAst(location, type, value) {
        var _this = _super.call(this, location) || this;
        _this.type = type;
        _this.value = value;
        return _this;
    }
    CssInlineRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssInlineRule(this, context);
    };
    return CssInlineRuleAst;
}(CssRuleAst));
var CssSelectorRuleAst = /** @class */ (function (_super) {
    __extends$3(CssSelectorRuleAst, _super);
    function CssSelectorRuleAst(location, selectors, block) {
        var _this = _super.call(this, location, BlockType.Selector, block) || this;
        _this.selectors = selectors;
        _this.strValue = selectors.map(function (selector) { return selector.strValue; }).join(',');
        return _this;
    }
    CssSelectorRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssSelectorRule(this, context);
    };
    return CssSelectorRuleAst;
}(CssBlockRuleAst));
var CssDefinitionAst = /** @class */ (function (_super) {
    __extends$3(CssDefinitionAst, _super);
    function CssDefinitionAst(location, property, value) {
        var _this = _super.call(this, location) || this;
        _this.property = property;
        _this.value = value;
        return _this;
    }
    CssDefinitionAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssDefinition(this, context);
    };
    return CssDefinitionAst;
}(CssAst));
var CssSelectorPartAst = /** @class */ (function (_super) {
    __extends$3(CssSelectorPartAst, _super);
    function CssSelectorPartAst(location) {
        return _super.call(this, location) || this;
    }
    return CssSelectorPartAst;
}(CssAst));
var CssSelectorAst = /** @class */ (function (_super) {
    __extends$3(CssSelectorAst, _super);
    function CssSelectorAst(location, selectorParts) {
        var _this = _super.call(this, location) || this;
        _this.selectorParts = selectorParts;
        _this.strValue = selectorParts.map(function (part) { return part.strValue; }).join('');
        return _this;
    }
    CssSelectorAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssSelector(this, context);
    };
    return CssSelectorAst;
}(CssSelectorPartAst));
var CssSimpleSelectorAst = /** @class */ (function (_super) {
    __extends$3(CssSimpleSelectorAst, _super);
    function CssSimpleSelectorAst(location, tokens, strValue, pseudoSelectors, operator) {
        var _this = _super.call(this, location) || this;
        _this.tokens = tokens;
        _this.strValue = strValue;
        _this.pseudoSelectors = pseudoSelectors;
        _this.operator = operator;
        return _this;
    }
    CssSimpleSelectorAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssSimpleSelector(this, context);
    };
    return CssSimpleSelectorAst;
}(CssSelectorPartAst));
var CssPseudoSelectorAst = /** @class */ (function (_super) {
    __extends$3(CssPseudoSelectorAst, _super);
    function CssPseudoSelectorAst(location, strValue, name, tokens, innerSelectors) {
        var _this = _super.call(this, location) || this;
        _this.strValue = strValue;
        _this.name = name;
        _this.tokens = tokens;
        _this.innerSelectors = innerSelectors;
        return _this;
    }
    CssPseudoSelectorAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssPseudoSelector(this, context);
    };
    return CssPseudoSelectorAst;
}(CssSelectorPartAst));
var CssBlockAst = /** @class */ (function (_super) {
    __extends$3(CssBlockAst, _super);
    function CssBlockAst(location, entries) {
        var _this = _super.call(this, location) || this;
        _this.entries = entries;
        return _this;
    }
    CssBlockAst.prototype.visit = function (visitor, context) { return visitor.visitCssBlock(this, context); };
    return CssBlockAst;
}(CssAst));
/*
 a style block is different from a standard block because it contains
 css prop:value definitions. A regular block can contain a list of Ast entries.
 */
var CssStylesBlockAst = /** @class */ (function (_super) {
    __extends$3(CssStylesBlockAst, _super);
    function CssStylesBlockAst(location, definitions) {
        var _this = _super.call(this, location, definitions) || this;
        _this.definitions = definitions;
        return _this;
    }
    CssStylesBlockAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssStylesBlock(this, context);
    };
    return CssStylesBlockAst;
}(CssBlockAst));
var CssStyleSheetAst = /** @class */ (function (_super) {
    __extends$3(CssStyleSheetAst, _super);
    function CssStyleSheetAst(location, rules) {
        var _this = _super.call(this, location) || this;
        _this.rules = rules;
        return _this;
    }
    CssStyleSheetAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssStyleSheet(this, context);
    };
    return CssStyleSheetAst;
}(CssAst));
var CssUnknownRuleAst = /** @class */ (function (_super) {
    __extends$3(CssUnknownRuleAst, _super);
    function CssUnknownRuleAst(location, ruleName, tokens) {
        var _this = _super.call(this, location) || this;
        _this.ruleName = ruleName;
        _this.tokens = tokens;
        return _this;
    }
    CssUnknownRuleAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssUnknownRule(this, context);
    };
    return CssUnknownRuleAst;
}(CssRuleAst));
var CssUnknownTokenListAst = /** @class */ (function (_super) {
    __extends$3(CssUnknownTokenListAst, _super);
    function CssUnknownTokenListAst(location, name, tokens) {
        var _this = _super.call(this, location) || this;
        _this.name = name;
        _this.tokens = tokens;
        return _this;
    }
    CssUnknownTokenListAst.prototype.visit = function (visitor, context) {
        return visitor.visitCssUnknownTokenList(this, context);
    };
    return CssUnknownTokenListAst;
}(CssRuleAst));
function mergeTokens(tokens, separator) {
    if (separator === void 0) { separator = ''; }
    var mainToken = tokens[0];
    var str = mainToken.strValue;
    for (var i = 1; i < tokens.length; i++) {
        str += separator + tokens[i].strValue;
    }
    return new CssToken(mainToken.index, mainToken.column, mainToken.line, mainToken.type, str);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SPACE_OPERATOR = ' ';
var SLASH_CHARACTER = '/';
var GT_CHARACTER = '>';
var TRIPLE_GT_OPERATOR_STR = '>>>';
var DEEP_OPERATOR_STR = '/deep/';
var EOF_DELIM_FLAG = 1;
var RBRACE_DELIM_FLAG = 2;
var LBRACE_DELIM_FLAG = 4;
var COMMA_DELIM_FLAG = 8;
var COLON_DELIM_FLAG = 16;
var SEMICOLON_DELIM_FLAG = 32;
var NEWLINE_DELIM_FLAG = 64;
var RPAREN_DELIM_FLAG = 128;
var LPAREN_DELIM_FLAG = 256;
var SPACE_DELIM_FLAG = 512;
function _pseudoSelectorSupportsInnerSelectors(name) {
    return ['not', 'host', 'host-context'].indexOf(name) >= 0;
}
function isSelectorOperatorCharacter(code) {
    switch (code) {
        case $SLASH:
        case $TILDA:
        case $PLUS:
        case $GT:
            return true;
        default:
            return isWhitespace(code);
    }
}
function getDelimFromCharacter(code) {
    switch (code) {
        case $EOF:
            return EOF_DELIM_FLAG;
        case $COMMA:
            return COMMA_DELIM_FLAG;
        case $COLON:
            return COLON_DELIM_FLAG;
        case $SEMICOLON:
            return SEMICOLON_DELIM_FLAG;
        case $RBRACE:
            return RBRACE_DELIM_FLAG;
        case $LBRACE:
            return LBRACE_DELIM_FLAG;
        case $RPAREN:
            return RPAREN_DELIM_FLAG;
        case $SPACE:
        case $TAB:
            return SPACE_DELIM_FLAG;
        default:
            return isNewline(code) ? NEWLINE_DELIM_FLAG : 0;
    }
}
function characterContainsDelimiter(code, delimiters) {
    return (getDelimFromCharacter(code) & delimiters) > 0;
}
var ParsedCssResult = /** @class */ (function () {
    function ParsedCssResult(errors, ast) {
        this.errors = errors;
        this.ast = ast;
    }
    return ParsedCssResult;
}());
var CssParser = /** @class */ (function () {
    function CssParser() {
        this._errors = [];
    }
    /**
     * @param css the CSS code that will be parsed
     * @param url the name of the CSS file containing the CSS source code
     */
    CssParser.prototype.parse = function (css, url) {
        var lexer = new CssLexer();
        this._file = new ParseSourceFile(css, url);
        this._scanner = lexer.scan(css, false);
        var ast = this._parseStyleSheet(EOF_DELIM_FLAG);
        var errors = this._errors;
        this._errors = [];
        var result = new ParsedCssResult(errors, ast);
        this._file = null;
        this._scanner = null;
        return result;
    };
    /** @internal */
    CssParser.prototype._parseStyleSheet = function (delimiters) {
        var results = [];
        this._scanner.consumeEmptyStatements();
        while (this._scanner.peek != $EOF) {
            this._scanner.setMode(CssLexerMode.BLOCK);
            results.push(this._parseRule(delimiters));
        }
        var span = null;
        if (results.length > 0) {
            var firstRule = results[0];
            // we collect the last token like so incase there was an
            // EOF token that was emitted sometime during the lexing
            span = this._generateSourceSpan(firstRule, this._lastToken);
        }
        return new CssStyleSheetAst(span, results);
    };
    /** @internal */
    CssParser.prototype._getSourceContent = function () { return this._scanner != null ? this._scanner.input : ''; };
    /** @internal */
    CssParser.prototype._extractSourceContent = function (start, end) {
        return this._getSourceContent().substring(start, end + 1);
    };
    /** @internal */
    CssParser.prototype._generateSourceSpan = function (start, end) {
        if (end === void 0) { end = null; }
        var startLoc;
        if (start instanceof CssAst) {
            startLoc = start.location.start;
        }
        else {
            var token = start;
            if (token == null) {
                // the data here is invalid, however, if and when this does
                // occur, any other errors associated with this will be collected
                token = this._lastToken;
            }
            startLoc = new ParseLocation(this._file, token.index, token.line, token.column);
        }
        if (end == null) {
            end = this._lastToken;
        }
        var endLine = -1;
        var endColumn = -1;
        var endIndex = -1;
        if (end instanceof CssAst) {
            endLine = end.location.end.line;
            endColumn = end.location.end.col;
            endIndex = end.location.end.offset;
        }
        else if (end instanceof CssToken) {
            endLine = end.line;
            endColumn = end.column;
            endIndex = end.index;
        }
        var endLoc = new ParseLocation(this._file, endIndex, endLine, endColumn);
        return new ParseSourceSpan(startLoc, endLoc);
    };
    /** @internal */
    CssParser.prototype._resolveBlockType = function (token) {
        switch (token.strValue) {
            case '@-o-keyframes':
            case '@-moz-keyframes':
            case '@-webkit-keyframes':
            case '@keyframes':
                return BlockType.Keyframes;
            case '@charset':
                return BlockType.Charset;
            case '@import':
                return BlockType.Import;
            case '@namespace':
                return BlockType.Namespace;
            case '@page':
                return BlockType.Page;
            case '@document':
                return BlockType.Document;
            case '@media':
                return BlockType.MediaQuery;
            case '@font-face':
                return BlockType.FontFace;
            case '@viewport':
                return BlockType.Viewport;
            case '@supports':
                return BlockType.Supports;
            default:
                return BlockType.Unsupported;
        }
    };
    /** @internal */
    CssParser.prototype._parseRule = function (delimiters) {
        if (this._scanner.peek == $AT) {
            return this._parseAtRule(delimiters);
        }
        return this._parseSelectorRule(delimiters);
    };
    /** @internal */
    CssParser.prototype._parseAtRule = function (delimiters) {
        var start = this._getScannerIndex();
        this._scanner.setMode(CssLexerMode.BLOCK);
        var token = this._scan();
        var startToken = token;
        this._assertCondition(token.type == CssTokenType.AtKeyword, "The CSS Rule " + token.strValue + " is not a valid [@] rule.", token);
        var block;
        var type = this._resolveBlockType(token);
        var span;
        var tokens;
        var endToken;
        var end;
        var strValue;
        var query;
        switch (type) {
            case BlockType.Charset:
            case BlockType.Namespace:
            case BlockType.Import:
                var value = this._parseValue(delimiters);
                this._scanner.setMode(CssLexerMode.BLOCK);
                this._scanner.consumeEmptyStatements();
                span = this._generateSourceSpan(startToken, value);
                return new CssInlineRuleAst(span, type, value);
            case BlockType.Viewport:
            case BlockType.FontFace:
                block = this._parseStyleBlock(delimiters);
                span = this._generateSourceSpan(startToken, block);
                return new CssBlockRuleAst(span, type, block);
            case BlockType.Keyframes:
                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);
                // keyframes only have one identifier name
                var name_1 = tokens[0];
                block = this._parseKeyframeBlock(delimiters);
                span = this._generateSourceSpan(startToken, block);
                return new CssKeyframeRuleAst(span, name_1, block);
            case BlockType.MediaQuery:
                this._scanner.setMode(CssLexerMode.MEDIA_QUERY);
                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);
                endToken = tokens[tokens.length - 1];
                // we do not track the whitespace after the mediaQuery predicate ends
                // so we have to calculate the end string value on our own
                end = endToken.index + endToken.strValue.length - 1;
                strValue = this._extractSourceContent(start, end);
                span = this._generateSourceSpan(startToken, endToken);
                query = new CssAtRulePredicateAst(span, strValue, tokens);
                block = this._parseBlock(delimiters);
                strValue = this._extractSourceContent(start, this._getScannerIndex() - 1);
                span = this._generateSourceSpan(startToken, block);
                return new CssMediaQueryRuleAst(span, strValue, query, block);
            case BlockType.Document:
            case BlockType.Supports:
            case BlockType.Page:
                this._scanner.setMode(CssLexerMode.AT_RULE_QUERY);
                tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);
                endToken = tokens[tokens.length - 1];
                // we do not track the whitespace after this block rule predicate ends
                // so we have to calculate the end string value on our own
                end = endToken.index + endToken.strValue.length - 1;
                strValue = this._extractSourceContent(start, end);
                span = this._generateSourceSpan(startToken, tokens[tokens.length - 1]);
                query = new CssAtRulePredicateAst(span, strValue, tokens);
                block = this._parseBlock(delimiters);
                strValue = this._extractSourceContent(start, block.end.offset);
                span = this._generateSourceSpan(startToken, block);
                return new CssBlockDefinitionRuleAst(span, strValue, type, query, block);
            // if a custom @rule { ... } is used it should still tokenize the insides
            default:
                var listOfTokens_1 = [];
                var tokenName = token.strValue;
                this._scanner.setMode(CssLexerMode.ALL);
                this._error(generateErrorMessage(this._getSourceContent(), "The CSS \"at\" rule \"" + tokenName + "\" is not allowed to used here", token.strValue, token.index, token.line, token.column), token);
                this._collectUntilDelim(delimiters | LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG)
                    .forEach(function (token) { listOfTokens_1.push(token); });
                if (this._scanner.peek == $LBRACE) {
                    listOfTokens_1.push(this._consume(CssTokenType.Character, '{'));
                    this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG)
                        .forEach(function (token) { listOfTokens_1.push(token); });
                    listOfTokens_1.push(this._consume(CssTokenType.Character, '}'));
                }
                endToken = listOfTokens_1[listOfTokens_1.length - 1];
                span = this._generateSourceSpan(startToken, endToken);
                return new CssUnknownRuleAst(span, tokenName, listOfTokens_1);
        }
    };
    /** @internal */
    CssParser.prototype._parseSelectorRule = function (delimiters) {
        var start = this._getScannerIndex();
        var selectors = this._parseSelectors(delimiters);
        var block = this._parseStyleBlock(delimiters);
        var ruleAst;
        var span;
        var startSelector = selectors[0];
        if (block != null) {
            span = this._generateSourceSpan(startSelector, block);
            ruleAst = new CssSelectorRuleAst(span, selectors, block);
        }
        else {
            var name_2 = this._extractSourceContent(start, this._getScannerIndex() - 1);
            var innerTokens_1 = [];
            selectors.forEach(function (selector) {
                selector.selectorParts.forEach(function (part) {
                    part.tokens.forEach(function (token) { innerTokens_1.push(token); });
                });
            });
            var endToken = innerTokens_1[innerTokens_1.length - 1];
            span = this._generateSourceSpan(startSelector, endToken);
            ruleAst = new CssUnknownTokenListAst(span, name_2, innerTokens_1);
        }
        this._scanner.setMode(CssLexerMode.BLOCK);
        this._scanner.consumeEmptyStatements();
        return ruleAst;
    };
    /** @internal */
    CssParser.prototype._parseSelectors = function (delimiters) {
        delimiters |= LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG;
        var selectors = [];
        var isParsingSelectors = true;
        while (isParsingSelectors) {
            selectors.push(this._parseSelector(delimiters));
            isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);
            if (isParsingSelectors) {
                this._consume(CssTokenType.Character, ',');
                isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);
                if (isParsingSelectors) {
                    this._scanner.consumeWhitespace();
                }
            }
        }
        return selectors;
    };
    /** @internal */
    CssParser.prototype._scan = function () {
        var output = this._scanner.scan();
        var token = output.token;
        var error = output.error;
        if (error != null) {
            this._error(getRawMessage(error), token);
        }
        this._lastToken = token;
        return token;
    };
    /** @internal */
    CssParser.prototype._getScannerIndex = function () { return this._scanner.index; };
    /** @internal */
    CssParser.prototype._consume = function (type, value) {
        if (value === void 0) { value = null; }
        var output = this._scanner.consume(type, value);
        var token = output.token;
        var error = output.error;
        if (error != null) {
            this._error(getRawMessage(error), token);
        }
        this._lastToken = token;
        return token;
    };
    /** @internal */
    CssParser.prototype._parseKeyframeBlock = function (delimiters) {
        delimiters |= RBRACE_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);
        var startToken = this._consume(CssTokenType.Character, '{');
        var definitions = [];
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            definitions.push(this._parseKeyframeDefinition(delimiters));
        }
        var endToken = this._consume(CssTokenType.Character, '}');
        var span = this._generateSourceSpan(startToken, endToken);
        return new CssBlockAst(span, definitions);
    };
    /** @internal */
    CssParser.prototype._parseKeyframeDefinition = function (delimiters) {
        var start = this._getScannerIndex();
        var stepTokens = [];
        delimiters |= LBRACE_DELIM_FLAG;
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            stepTokens.push(this._parseKeyframeLabel(delimiters | COMMA_DELIM_FLAG));
            if (this._scanner.peek != $LBRACE) {
                this._consume(CssTokenType.Character, ',');
            }
        }
        var stylesBlock = this._parseStyleBlock(delimiters | RBRACE_DELIM_FLAG);
        var span = this._generateSourceSpan(stepTokens[0], stylesBlock);
        var ast = new CssKeyframeDefinitionAst(span, stepTokens, stylesBlock);
        this._scanner.setMode(CssLexerMode.BLOCK);
        return ast;
    };
    /** @internal */
    CssParser.prototype._parseKeyframeLabel = function (delimiters) {
        this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);
        return mergeTokens(this._collectUntilDelim(delimiters));
    };
    /** @internal */
    CssParser.prototype._parsePseudoSelector = function (delimiters) {
        var start = this._getScannerIndex();
        delimiters &= ~COMMA_DELIM_FLAG;
        // we keep the original value since we may use it to recurse when :not, :host are used
        var startingDelims = delimiters;
        var startToken = this._consume(CssTokenType.Character, ':');
        var tokens = [startToken];
        if (this._scanner.peek == $COLON) {
            tokens.push(this._consume(CssTokenType.Character, ':'));
        }
        var innerSelectors = [];
        this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR);
        // host, host-context, lang, not, nth-child are all identifiers
        var pseudoSelectorToken = this._consume(CssTokenType.Identifier);
        var pseudoSelectorName = pseudoSelectorToken.strValue;
        tokens.push(pseudoSelectorToken);
        // host(), lang(), nth-child(), etc...
        if (this._scanner.peek == $LPAREN) {
            this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS);
            var openParenToken = this._consume(CssTokenType.Character, '(');
            tokens.push(openParenToken);
            // :host(innerSelector(s)), :not(selector), etc...
            if (_pseudoSelectorSupportsInnerSelectors(pseudoSelectorName)) {
                var innerDelims = startingDelims | LPAREN_DELIM_FLAG | RPAREN_DELIM_FLAG;
                if (pseudoSelectorName == 'not') {
                    // the inner selector inside of :not(...) can only be one
                    // CSS selector (no commas allowed) ... This is according
                    // to the CSS specification
                    innerDelims |= COMMA_DELIM_FLAG;
                }
                // :host(a, b, c) {
                this._parseSelectors(innerDelims).forEach(function (selector, index) {
                    innerSelectors.push(selector);
                });
            }
            else {
                // this branch is for things like "en-us, 2k + 1, etc..."
                // which all end up in pseudoSelectors like :lang, :nth-child, etc..
                var innerValueDelims = delimiters | LBRACE_DELIM_FLAG | COLON_DELIM_FLAG |
                    RPAREN_DELIM_FLAG | LPAREN_DELIM_FLAG;
                while (!characterContainsDelimiter(this._scanner.peek, innerValueDelims)) {
                    var token = this._scan();
                    tokens.push(token);
                }
            }
            var closeParenToken = this._consume(CssTokenType.Character, ')');
            tokens.push(closeParenToken);
        }
        var end = this._getScannerIndex() - 1;
        var strValue = this._extractSourceContent(start, end);
        var endToken = tokens[tokens.length - 1];
        var span = this._generateSourceSpan(startToken, endToken);
        return new CssPseudoSelectorAst(span, strValue, pseudoSelectorName, tokens, innerSelectors);
    };
    /** @internal */
    CssParser.prototype._parseSimpleSelector = function (delimiters) {
        var start = this._getScannerIndex();
        delimiters |= COMMA_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.SELECTOR);
        var selectorCssTokens = [];
        var pseudoSelectors = [];
        var previousToken = undefined;
        var selectorPartDelimiters = delimiters | SPACE_DELIM_FLAG;
        var loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);
        var hasAttributeError = false;
        while (loopOverSelector) {
            var peek = this._scanner.peek;
            switch (peek) {
                case $COLON:
                    var innerPseudo = this._parsePseudoSelector(delimiters);
                    pseudoSelectors.push(innerPseudo);
                    this._scanner.setMode(CssLexerMode.SELECTOR);
                    break;
                case $LBRACKET:
                    // we set the mode after the scan because attribute mode does not
                    // allow attribute [] values. And this also will catch any errors
                    // if an extra "[" is used inside.
                    selectorCssTokens.push(this._scan());
                    this._scanner.setMode(CssLexerMode.ATTRIBUTE_SELECTOR);
                    break;
                case $RBRACKET:
                    if (this._scanner.getMode() != CssLexerMode.ATTRIBUTE_SELECTOR) {
                        hasAttributeError = true;
                    }
                    // we set the mode early because attribute mode does not
                    // allow attribute [] values
                    this._scanner.setMode(CssLexerMode.SELECTOR);
                    selectorCssTokens.push(this._scan());
                    break;
                default:
                    if (isSelectorOperatorCharacter(peek)) {
                        loopOverSelector = false;
                        continue;
                    }
                    var token = this._scan();
                    previousToken = token;
                    selectorCssTokens.push(token);
                    break;
            }
            loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);
        }
        hasAttributeError =
            hasAttributeError || this._scanner.getMode() == CssLexerMode.ATTRIBUTE_SELECTOR;
        if (hasAttributeError) {
            this._error("Unbalanced CSS attribute selector at column " + previousToken.line + ":" + previousToken.column, previousToken);
        }
        var end = this._getScannerIndex() - 1;
        // this happens if the selector is not directly followed by
        // a comma or curly brace without a space in between
        var operator = null;
        var operatorScanCount = 0;
        var lastOperatorToken = null;
        if (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            while (operator == null && !characterContainsDelimiter(this._scanner.peek, delimiters) &&
                isSelectorOperatorCharacter(this._scanner.peek)) {
                var token = this._scan();
                var tokenOperator = token.strValue;
                operatorScanCount++;
                lastOperatorToken = token;
                if (tokenOperator != SPACE_OPERATOR) {
                    switch (tokenOperator) {
                        case SLASH_CHARACTER:
                            // /deep/ operator
                            var deepToken = this._consume(CssTokenType.Identifier);
                            var deepSlash = this._consume(CssTokenType.Character);
                            var index = lastOperatorToken.index;
                            var line = lastOperatorToken.line;
                            var column = lastOperatorToken.column;
                            if (deepToken != null && deepToken.strValue.toLowerCase() == 'deep' &&
                                deepSlash.strValue == SLASH_CHARACTER) {
                                token = new CssToken(lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line, CssTokenType.Identifier, DEEP_OPERATOR_STR);
                            }
                            else {
                                var text = SLASH_CHARACTER + deepToken.strValue + deepSlash.strValue;
                                this._error(generateErrorMessage(this._getSourceContent(), text + " is an invalid CSS operator", text, index, line, column), lastOperatorToken);
                                token = new CssToken(index, column, line, CssTokenType.Invalid, text);
                            }
                            break;
                        case GT_CHARACTER:
                            // >>> operator
                            if (this._scanner.peek == $GT && this._scanner.peekPeek == $GT) {
                                this._consume(CssTokenType.Character, GT_CHARACTER);
                                this._consume(CssTokenType.Character, GT_CHARACTER);
                                token = new CssToken(lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line, CssTokenType.Identifier, TRIPLE_GT_OPERATOR_STR);
                            }
                            break;
                    }
                    operator = token;
                }
            }
            // so long as there is an operator then we can have an
            // ending value that is beyond the selector value ...
            // otherwise it's just a bunch of trailing whitespace
            if (operator != null) {
                end = operator.index;
            }
        }
        this._scanner.consumeWhitespace();
        var strValue = this._extractSourceContent(start, end);
        // if we do come across one or more spaces inside of
        // the operators loop then an empty space is still a
        // valid operator to use if something else was not found
        if (operator == null && operatorScanCount > 0 && this._scanner.peek != $LBRACE) {
            operator = lastOperatorToken;
        }
        // please note that `endToken` is reassigned multiple times below
        // so please do not optimize the if statements into if/elseif
        var startTokenOrAst = null;
        var endTokenOrAst = null;
        if (selectorCssTokens.length > 0) {
            startTokenOrAst = startTokenOrAst || selectorCssTokens[0];
            endTokenOrAst = selectorCssTokens[selectorCssTokens.length - 1];
        }
        if (pseudoSelectors.length > 0) {
            startTokenOrAst = startTokenOrAst || pseudoSelectors[0];
            endTokenOrAst = pseudoSelectors[pseudoSelectors.length - 1];
        }
        if (operator != null) {
            startTokenOrAst = startTokenOrAst || operator;
            endTokenOrAst = operator;
        }
        var span = this._generateSourceSpan(startTokenOrAst, endTokenOrAst);
        return new CssSimpleSelectorAst(span, selectorCssTokens, strValue, pseudoSelectors, operator);
    };
    /** @internal */
    CssParser.prototype._parseSelector = function (delimiters) {
        delimiters |= COMMA_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.SELECTOR);
        var simpleSelectors = [];
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            simpleSelectors.push(this._parseSimpleSelector(delimiters));
            this._scanner.consumeWhitespace();
        }
        var firstSelector = simpleSelectors[0];
        var lastSelector = simpleSelectors[simpleSelectors.length - 1];
        var span = this._generateSourceSpan(firstSelector, lastSelector);
        return new CssSelectorAst(span, simpleSelectors);
    };
    /** @internal */
    CssParser.prototype._parseValue = function (delimiters) {
        delimiters |= RBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG | NEWLINE_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.STYLE_VALUE);
        var start = this._getScannerIndex();
        var tokens = [];
        var wsStr = '';
        var previous = undefined;
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            var token = void 0;
            if (previous != null && previous.type == CssTokenType.Identifier &&
                this._scanner.peek == $LPAREN) {
                token = this._consume(CssTokenType.Character, '(');
                tokens.push(token);
                this._scanner.setMode(CssLexerMode.STYLE_VALUE_FUNCTION);
                token = this._scan();
                tokens.push(token);
                this._scanner.setMode(CssLexerMode.STYLE_VALUE);
                token = this._consume(CssTokenType.Character, ')');
                tokens.push(token);
            }
            else {
                token = this._scan();
                if (token.type == CssTokenType.Whitespace) {
                    wsStr += token.strValue;
                }
                else {
                    wsStr = '';
                    tokens.push(token);
                }
            }
            previous = token;
        }
        var end = this._getScannerIndex() - 1;
        this._scanner.consumeWhitespace();
        var code = this._scanner.peek;
        if (code == $SEMICOLON) {
            this._consume(CssTokenType.Character, ';');
        }
        else if (code != $RBRACE) {
            this._error(generateErrorMessage(this._getSourceContent(), "The CSS key/value definition did not end with a semicolon", previous.strValue, previous.index, previous.line, previous.column), previous);
        }
        var strValue = this._extractSourceContent(start, end);
        var startToken = tokens[0];
        var endToken = tokens[tokens.length - 1];
        var span = this._generateSourceSpan(startToken, endToken);
        return new CssStyleValueAst(span, tokens, strValue);
    };
    /** @internal */
    CssParser.prototype._collectUntilDelim = function (delimiters, assertType) {
        if (assertType === void 0) { assertType = null; }
        var tokens = [];
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            var val = assertType != null ? this._consume(assertType) : this._scan();
            tokens.push(val);
        }
        return tokens;
    };
    /** @internal */
    CssParser.prototype._parseBlock = function (delimiters) {
        delimiters |= RBRACE_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.BLOCK);
        var startToken = this._consume(CssTokenType.Character, '{');
        this._scanner.consumeEmptyStatements();
        var results = [];
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            results.push(this._parseRule(delimiters));
        }
        var endToken = this._consume(CssTokenType.Character, '}');
        this._scanner.setMode(CssLexerMode.BLOCK);
        this._scanner.consumeEmptyStatements();
        var span = this._generateSourceSpan(startToken, endToken);
        return new CssBlockAst(span, results);
    };
    /** @internal */
    CssParser.prototype._parseStyleBlock = function (delimiters) {
        delimiters |= RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG;
        this._scanner.setMode(CssLexerMode.STYLE_BLOCK);
        var startToken = this._consume(CssTokenType.Character, '{');
        if (startToken.numValue != $LBRACE) {
            return null;
        }
        var definitions = [];
        this._scanner.consumeEmptyStatements();
        while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {
            definitions.push(this._parseDefinition(delimiters));
            this._scanner.consumeEmptyStatements();
        }
        var endToken = this._consume(CssTokenType.Character, '}');
        this._scanner.setMode(CssLexerMode.STYLE_BLOCK);
        this._scanner.consumeEmptyStatements();
        var span = this._generateSourceSpan(startToken, endToken);
        return new CssStylesBlockAst(span, definitions);
    };
    /** @internal */
    CssParser.prototype._parseDefinition = function (delimiters) {
        this._scanner.setMode(CssLexerMode.STYLE_BLOCK);
        var prop = this._consume(CssTokenType.Identifier);
        var parseValue = false;
        var value = null;
        var endToken = prop;
        // the colon value separates the prop from the style.
        // there are a few cases as to what could happen if it
        // is missing
        switch (this._scanner.peek) {
            case $SEMICOLON:
            case $RBRACE:
            case $EOF:
                parseValue = false;
                break;
            default:
                var propStr_1 = [prop.strValue];
                if (this._scanner.peek != $COLON) {
                    // this will throw the error
                    var nextValue = this._consume(CssTokenType.Character, ':');
                    propStr_1.push(nextValue.strValue);
                    var remainingTokens = this._collectUntilDelim(delimiters | COLON_DELIM_FLAG | SEMICOLON_DELIM_FLAG, CssTokenType.Identifier);
                    if (remainingTokens.length > 0) {
                        remainingTokens.forEach(function (token) { propStr_1.push(token.strValue); });
                    }
                    endToken = prop =
                        new CssToken(prop.index, prop.column, prop.line, prop.type, propStr_1.join(' '));
                }
                // this means we've reached the end of the definition and/or block
                if (this._scanner.peek == $COLON) {
                    this._consume(CssTokenType.Character, ':');
                    parseValue = true;
                }
                break;
        }
        if (parseValue) {
            value = this._parseValue(delimiters);
            endToken = value;
        }
        else {
            this._error(generateErrorMessage(this._getSourceContent(), "The CSS property was not paired with a style value", prop.strValue, prop.index, prop.line, prop.column), prop);
        }
        var span = this._generateSourceSpan(prop, endToken);
        return new CssDefinitionAst(span, prop, value);
    };
    /** @internal */
    CssParser.prototype._assertCondition = function (status, errorMessage, problemToken) {
        if (!status) {
            this._error(errorMessage, problemToken);
            return true;
        }
        return false;
    };
    /** @internal */
    CssParser.prototype._error = function (message, problemToken) {
        var length = problemToken.strValue.length;
        var error = CssParseError.create(this._file, 0, problemToken.line, problemToken.column, length, message);
        this._errors.push(error);
    };
    return CssParser;
}());
var CssParseError = /** @class */ (function (_super) {
    __extends$2(CssParseError, _super);
    function CssParseError(span, message) {
        return _super.call(this, span, message) || this;
    }
    CssParseError.create = function (file, offset, line, col, length, errMsg) {
        var start = new ParseLocation(file, offset, line, col);
        var end = new ParseLocation(file, offset, line, col + length);
        var span = new ParseSourceSpan(start, end);
        return new CssParseError(span, 'CSS Parse Error: ' + errMsg);
    };
    return CssParseError;
}(ParseError));

var parseCss = function (text) {
    var parser = new CssParser();
    return parser.parse(text, '').ast;
};

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * This class represents the individual directives and wrapps
 * their `StaticSymbol`s produced by the `@angular/compiler`.
 *
 * @export
 * @class DirectiveSymbol
 * @extends {Symbol}
 */
var DirectiveSymbol = /** @class */ (function (_super) {
    __extends$1(DirectiveSymbol, _super);
    /**
     * Creates an instance of DirectiveSymbol.
     *
     * @param {Program} program
     * @param {StaticSymbol} symbol
     * @param {CompileMetadataResolver} metadataResolver
     * @param {DirectiveNormalizer} directiveNormalizer
     * @param {DirectiveResolver} resolver
     * @param {StaticReflector} reflector
     * @param {ResourceResolver} resourceResolver
     * @param {ContextSymbols} projectSymbols
     *
     * @memberOf DirectiveSymbol
     */
    function DirectiveSymbol(program, symbol, metadataResolver, directiveNormalizer, resolver, reflector, resourceResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.metadataResolver = metadataResolver;
        _this.directiveNormalizer = directiveNormalizer;
        _this.resolver = resolver;
        _this.reflector = reflector;
        _this.resourceResolver = resourceResolver;
        _this.projectSymbols = projectSymbols;
        _this.urlResolver = new _angular_compiler.UrlResolver();
        return _this;
    }
    /**
     * Returns the non-resolved metadata for given directive.
     * If it is a component, this means that the external templates
     * and styles won't be read from the drive. Also, the paths to
     * external metadata won't be resolved.
     *
     * @returns {CompileDirectiveMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getNonResolvedMetadata = function () {
        var data = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
        if (data) {
            return data.metadata;
        }
        return null;
    };
    // TODO: use the normalizer's cache in order to prevent repetative I/O operations
    /**
     * Returns the normalized and resolved metadata for given directive or component.
     * For components, all the external templates and styles will be read and
     * set as values of the returned `CompileTemplateMetadata` properties.
     *
     * @returns {CompileTemplateMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getResolvedMetadata = function () {
        var _this = this;
        var metadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
        var componentType = _angular_core.resolveForwardRef(this.symbol);
        if (!metadata) {
            return null;
        }
        var componentUrl = this.reflector.componentModuleUrl(componentType);
        var templateMetadata = metadata.metadata.template;
        // Required because otherwise the normalizer gets confused.
        if (!templateMetadata) {
            return null;
        }
        if (!templateMetadata.template && templateMetadata.templateUrl) {
            templateMetadata.templateUrl = this.urlResolver.resolve(componentUrl, templateMetadata.templateUrl);
            templateMetadata.template = this.resourceResolver.getSync(templateMetadata.templateUrl);
        }
        if (templateMetadata.styleUrls.length) {
            templateMetadata.styleUrls = templateMetadata.styleUrls.map(function (s) { return _this.urlResolver.resolve(componentUrl, s); });
            templateMetadata.styles = templateMetadata.styles.concat(templateMetadata.styleUrls.map(function (s) { return _this.resourceResolver.getSync(s); }));
        }
        var module = this.getModule();
        if (!module) {
            return null;
        }
        var config = Object.assign({}, templateMetadata, {
            ngModuleType: module.type.reference,
            moduleUrl: componentUrl,
            templateUrl: null,
            styleUrls: null,
            componentType: componentType
        });
        var currentMetadata = this.directiveNormalizer.normalizeTemplate(config);
        currentMetadata.template = templateMetadata.template;
        currentMetadata.templateUrl = templateMetadata.templateUrl;
        currentMetadata.styles = templateMetadata.styles;
        currentMetadata.styleUrls = templateMetadata.styleUrls;
        return currentMetadata;
    };
    /**
     * Returns the module where the given directive has been declared.
     *
     * @returns {(CompileNgModuleMetadata | undefined)}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getModule = function () {
        return this.projectSymbols.getAnalyzedModules().ngModuleByPipeOrDirective.get(this.symbol);
    };
    /**
     * Returns the ASTs of all styles of the target directive.
     *
     * @returns {CssAst[]}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getStyleAsts = function () {
        var metadata = this.getResolvedMetadata();
        if (metadata) {
            return metadata.styles.map(function (s) { return parseCss(s); });
        }
        return null;
    };
    /**
     * Returns the context into which the template of given
     * component is going to be compiled.
     *
     * @returns {DirectiveContext}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getDirectiveContext = function () {
        var _this = this;
        var analyzedModules = this.projectSymbols.getAnalyzedModules();
        var ngModule = analyzedModules.ngModuleByPipeOrDirective.get(this.symbol);
        if (!ngModule) {
            throw new Error('Cannot find module associated with the directive ' + this.symbol.name);
        }
        var resolvedDirectives = ngModule.transitiveModule.directives.map(function (d) {
            return _this.metadataResolver.getNonNormalizedDirectiveMetadata(d.reference);
        });
        // TypeScript doesn't handle well filtering & strictNull
        var tempDirectives = resolvedDirectives.map(function (d) {
            if (d) {
                return d.metadata.toSummary();
            }
            else {
                return null;
            }
        });
        var directives = [];
        for (var i = 0; i < tempDirectives.length; i += 1) {
            var dir = tempDirectives[i];
            if (dir) {
                directives.push(dir);
            }
        }
        var pipes = ngModule.transitiveModule.pipes.map(function (p) {
            return _this.metadataResolver.getOrLoadPipeMetadata(p.reference).toSummary();
        });
        var schemas = ngModule.schemas;
        return {
            pipes: pipes,
            directives: directives,
            schemas: schemas
        };
    };
    /**
     * Returns the compiled template of the target component.
     *
     * @returns {TemplateAstResult}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getTemplateAst = function () {
        var result;
        try {
            var resolvedMetadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
            var dirMetadata = this.getResolvedMetadata();
            if (dirMetadata) {
                var source = dirMetadata.template;
                if (!source) {
                    result = { errors: [{ message: 'Cannot find template for the directive' }] };
                }
                else {
                    var metadata = resolvedMetadata && resolvedMetadata.metadata;
                    if (metadata) {
                        var rawHtmlParser = new _angular_compiler.HtmlParser();
                        var htmlParser = new _angular_compiler.I18NHtmlParser(rawHtmlParser);
                        var expressionParser = new _angular_compiler.Parser(new _angular_compiler.Lexer());
                        var parser = void 0;
                        parser = new _angular_compiler.TemplateParser(new _angular_compiler.CompilerConfig(), this.reflector, expressionParser, new _angular_compiler.DomElementSchemaRegistry(), htmlParser, {
                            log: function () {
                                return null;
                            },
                            warn: function () {
                                return null;
                            }
                        }, []);
                        var htmlResult = htmlParser.parse(source, '');
                        var _a = this.getDirectiveContext(), directives = _a.directives, pipes = _a.pipes, schemas = _a.schemas;
                        var parseResult = parser.tryParseHtml(htmlResult, metadata, directives, pipes, schemas);
                        result = {
                            templateAst: parseResult.templateAst,
                            parseErrors: parseResult.errors,
                            errors: []
                        };
                    }
                    else {
                        result = { errors: [{ message: 'Cannot find metadata for the directive' }] };
                    }
                }
            }
            else {
                result = { errors: [{ message: 'Cannot find metadata for the directive' }] };
            }
        }
        catch (e) {
            result = { errors: [{ message: e.message }] };
        }
        return result;
    };
    DirectiveSymbol.prototype.getDependencies = function () {
        var _this = this;
        var summary = this.metadataResolver.getInjectableSummary(this.symbol);
        if (!summary) {
            return [];
        }
        else {
            return (summary.type.diDeps || []).map(function (d) {
                var token = d.token;
                if (d.token) {
                    if (d.token.identifier) {
                        token = d.token.identifier.reference;
                    }
                }
                var meta = new _angular_compiler.ProviderMeta(token, { useClass: d.value });
                return new ProviderSymbol(_this._program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
            });
        }
    };
    DirectiveSymbol.prototype.getProviders = function () {
        var _this = this;
        var meta = this.getNonResolvedMetadata();
        if (meta) {
            return (meta.providers || []).map(function (d) {
                return new ProviderSymbol(_this._program, d, _this.metadataResolver);
            });
        }
        return [];
    };
    DirectiveSymbol.prototype.getViewProviders = function () {
        var _this = this;
        var meta = this.getNonResolvedMetadata();
        if (meta) {
            return (meta.viewProviders || []).map(function (d) {
                return new ProviderSymbol(_this._program, d, _this.metadataResolver);
            });
        }
        else {
            return [];
        }
    };
    /**
     * Returns if the target directive is a component.
     *
     * @returns {boolean}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.isComponent = function () {
        var meta = this.getResolvedMetadata();
        if (meta) {
            return !!meta.template || !!meta.templateUrl;
        }
        else {
            return false;
        }
    };
    return DirectiveSymbol;
}(Symbol));

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ModuleSymbol = /** @class */ (function (_super) {
    __extends$4(ModuleSymbol, _super);
    function ModuleSymbol(program, symbol, metadataResolver, directiveNormalizer, resolver, pipeResolver, reflector, resourceResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.metadataResolver = metadataResolver;
        _this.directiveNormalizer = directiveNormalizer;
        _this.resolver = resolver;
        _this.pipeResolver = pipeResolver;
        _this.reflector = reflector;
        _this.resourceResolver = resourceResolver;
        _this.projectSymbols = projectSymbols;
        var meta = _this.metadataResolver.getNgModuleMetadata(symbol);
        if (meta) {
            _this.module = meta;
        }
        else {
            throw new Error('No metadata for ' + symbol.name);
        }
        return _this;
    }
    ModuleSymbol.prototype.getBootstrapComponents = function () {
        return this.getWrapperDirectives(this.module.bootstrapComponents);
    };
    ModuleSymbol.prototype.getDeclaredDirectives = function () {
        return this.getWrapperDirectives(this.module.declaredDirectives);
    };
    ModuleSymbol.prototype.getExportedDirectives = function () {
        return this.getWrapperDirectives(this.module.exportedDirectives);
    };
    ModuleSymbol.prototype.getExportedPipes = function () {
        return this.getWrappedPipes(this.module.exportedPipes);
    };
    ModuleSymbol.prototype.getDeclaredPipes = function () {
        return this.getWrappedPipes(this.module.declaredPipes);
    };
    ModuleSymbol.prototype.getImportedModules = function () {
        return this.getWrappedModules(this.module.importedModules);
    };
    ModuleSymbol.prototype.getExportedModules = function () {
        return this.getWrappedModules(this.module.exportedModules);
    };
    /**
     * Returns the summary of this context.
     *
     * @returns {(CompileNgModuleSummary | undefined)}
     *
     * @memberOf ModuleSymbol
     */
    ModuleSymbol.prototype.getModuleSummary = function () {
        return this.metadataResolver.getNgModuleSummary(this.symbol);
    };
    ModuleSymbol.prototype.getProviders = function () {
        var _this = this;
        return this.module.providers.map(function (p) {
            return new ProviderSymbol(_this._program, p, _this.metadataResolver);
        });
    };
    ModuleSymbol.prototype.getWrappedModules = function (modules) {
        var _this = this;
        return modules.map(function (s) {
            return new ModuleSymbol(_this._program, s.type.reference, _this.metadataResolver, _this.directiveNormalizer, _this.resolver, _this.pipeResolver, _this.reflector, _this.resourceResolver, _this.projectSymbols);
        });
    };
    ModuleSymbol.prototype.getWrappedPipes = function (pipes) {
        var _this = this;
        return pipes.map(function (i) {
            return new PipeSymbol(_this._program, i.reference, _this.pipeResolver, _this.metadataResolver, _this.projectSymbols);
        });
    };
    ModuleSymbol.prototype.getWrapperDirectives = function (dirs) {
        var _this = this;
        return dirs.map(function (i) {
            return new DirectiveSymbol(_this._program, i.reference, _this.metadataResolver, _this.directiveNormalizer, _this.resolver, _this.reflector, _this.resourceResolver, _this.projectSymbols);
        });
    };
    return ModuleSymbol;
}(Symbol));

/**
 * Creates a proxy which provides us access to the symbols
 * defined in given context (could be lazy loaded module or the root module).
 *
 * @export
 * @class ProjectSymbols
 */
var ProjectSymbols = /** @class */ (function () {
    /**
     * Creates an instance of ProjectSymbols.
     *
     * @param {ts.Program} program
     * @param {ResourceResolver} resourceResolver
     *
     * @memberOf ProjectSymbols
     */
    function ProjectSymbols(tsconfigPath, resourceResolver, errorReporter) {
        this.tsconfigPath = tsconfigPath;
        this.resourceResolver = resourceResolver;
        this.errorReporter = errorReporter;
        var config = _angular_compilerCli.readConfiguration(this.tsconfigPath);
        this.options = config.options;
        this.compilerHost = _angular_compilerCli_ngtools2.createCompilerHost({ options: config.options });
        // Replace all `\` with a forward slash to align with typescript's `normalizePath`.
        // On Windows, different slashes cause errors while trying to compare module symbols
        var rootNames = config.rootNames.map(function (rootName) { return rootName.replace(/\\/g, '/'); });
        this.program = _angular_compilerCli_ngtools2.createProgram({ rootNames: rootNames, options: config.options, host: this.compilerHost });
        this.init();
        // this.clearCaches();
    }
    /**
     * Returns the metadata associated to this module.
     *
     * @returns {ModuleSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getModules = function () {
        var _this = this;
        var resultMap = new Map();
        this.getAnalyzedModules().ngModules.forEach(function (m, s) {
            resultMap.set(m.type.reference, m);
        });
        var result = [];
        resultMap.forEach(function (v) {
            return result.push(new ModuleSymbol(_this.program.getTsProgram(), v.type.reference, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.pipeResolver, _this.reflector, _this.resourceResolver, _this));
        });
        return result;
    };
    /**
     * Returns all the directives available in the context.
     *
     * @returns {DirectiveSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getDirectives = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (symbol) { return _this.metadataResolver.isDirective(symbol); })
            .map(function (symbol) {
            return new DirectiveSymbol(_this.program.getTsProgram(), symbol, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.reflector, _this.resourceResolver, _this);
        });
    };
    /**
     * Returns all the pipes available in this module.
     *
     * @returns {PipeSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getPipes = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (v) { return _this.metadataResolver.isPipe(v); })
            .map(function (p) { return new PipeSymbol(_this.program.getTsProgram(), p, _this.pipeResolver, _this.metadataResolver, _this); });
    };
    /**
     * Returns all the providers available in this module.
     *
     * @returns {ProviderSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getProviders = function () {
        var resultSet = new Map();
        this.getModules().forEach(function (m) {
            m.getProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
        });
        this.getDirectives().forEach(function (d) {
            d.getProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
            d.getViewProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
        });
        var finalResult = [];
        resultSet.forEach(function (v) { return finalResult.push(v); });
        return finalResult;
    };
    /**
     * Returns directive based on `ClassDeclaration` node and a filename.
     *
     * @param {ts.ClassDeclaration} declaration
     * @param {string} fileName
     *
     * @memberOf DirectiveSymbol
     */
    ProjectSymbols.prototype.getDirectiveFromNode = function (declaration, fileName) {
        var sourceFile = this.program.getTsProgram().getSourceFile(fileName);
        if (!sourceFile) {
            throw new Error("Cannot get the program's source file");
        }
        var identifier = declaration.name;
        if (identifier) {
            return new DirectiveSymbol(this.program.getTsProgram(), this.reflector.getStaticSymbol(sourceFile.fileName, identifier.text), this.metadataResolver, this.directiveNormalizer, this.directiveResolver, this.reflector, this.resourceResolver, this);
        }
        else {
            return null;
        }
    };
    /** @internal */
    ProjectSymbols.prototype.getAnalyzedModules = function () {
        var analyzedModules = this.analyzedModules;
        if (!analyzedModules) {
            var analyzeHost = {
                isSourceFile: function (filePath) {
                    return true;
                }
            };
            analyzedModules = this.analyzedModules = _angular_compiler.analyzeNgModules(this.program.getTsProgram().getRootFileNames(), analyzeHost, this.staticSymbolResolver, this.metadataResolver);
        }
        return analyzedModules;
    };
    ProjectSymbols.prototype.extractProgramSymbols = function () {
        var _this = this;
        return [].concat.apply([], this.program
            .getTsProgram()
            .getSourceFiles()
            .map(function (f) { return _this.staticSymbolResolver.getSymbolsOf(f.fileName); }));
    };
    // private clearCaches() {
    //   this.metadataResolver.clearCache();
    //   this.directiveNormalizer.clearCache();
    // }
    ProjectSymbols.prototype.init = function () {
        var staticSymbolCache = new _angular_compiler.StaticSymbolCache();
        var summaryResolver = new _angular_compiler.AotSummaryResolver({
            loadSummary: function (filePath) {
                return '';
            },
            isSourceFile: function (sourceFilePath) {
                return true;
            },
            toSummaryFileName: function (host) {
                return '';
            },
            fromSummaryFileName: function (host) {
                return '';
            }
        }, staticSymbolCache);
        var parser = new _angular_compiler.HtmlParser();
        var config = new _angular_compiler.CompilerConfig({
            defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated,
            useJit: false
        });
        var defaultDir = this.program.getTsProgram().getCurrentDirectory();
        this.options.baseUrl = this.options.baseUrl || defaultDir;
        this.options.basePath = this.options.basePath || defaultDir;
        this.options.genDir = this.options.genDir || defaultDir;
        this.staticResolverHost = new _angular_compilerCli_src_transformers_compiler_host.TsCompilerAotCompilerTypeCheckHostAdapter(this.program.getTsProgram().getRootFileNames(), this.options, this.compilerHost, new _angular_compilerCli.MetadataCollector(), {
            generateFile: function (genFileName, baseFileName) { return new _angular_compiler.GeneratedFile('', '', ''); },
            findGeneratedFileNames: function (fileName) { return []; }
        });
        this.staticSymbolResolver = new _angular_compiler.StaticSymbolResolver(this.staticResolverHost, staticSymbolCache, summaryResolver, this.errorReporter);
        this.summaryResolver = new _angular_compiler.AotSummaryResolver(this.staticResolverHost, staticSymbolCache);
        this.reflector = new _angular_compiler.StaticReflector(this.summaryResolver, this.staticSymbolResolver, [], [], this.errorReporter);
        var ngModuleResolver = new _angular_compiler.NgModuleResolver(this.reflector);
        this.directiveResolver = new _angular_compiler.DirectiveResolver(this.reflector);
        this.pipeResolver = new _angular_compiler.PipeResolver(this.reflector);
        this.urlResolver = _angular_compiler.createOfflineCompileUrlResolver();
        this.directiveNormalizer = new _angular_compiler.DirectiveNormalizer(this.resourceResolver, this.urlResolver, parser, config);
        this.metadataResolver = new _angular_compiler.CompileMetadataResolver(new _angular_compiler.CompilerConfig(), parser, ngModuleResolver, this.directiveResolver, this.pipeResolver, summaryResolver, new _angular_compiler.DomElementSchemaRegistry(), this.directiveNormalizer, new _angular_core.ɵConsole(), staticSymbolCache, this.reflector);
    };
    return ProjectSymbols;
}());

exports.ProjectSymbols = ProjectSymbols;
exports.ModuleSymbol = ModuleSymbol;
exports.ProviderSymbol = ProviderSymbol;
exports.DirectiveSymbol = DirectiveSymbol;
exports.PipeSymbol = PipeSymbol;
exports.Symbol = Symbol;

Object.defineProperty(exports, '__esModule', { value: true });

})));
