var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { resolveForwardRef } from '@angular/core';
import { UrlResolver, HtmlParser, I18NHtmlParser, Lexer, Parser, TemplateParser, DomElementSchemaRegistry, CompilerConfig, ProviderMeta } from '@angular/compiler';
import { Symbol } from './symbol';
import { parseCss } from './css-parser/parse-css';
import { ProviderSymbol } from './provider-symbol';
/**
 * This class represents the individual directives and wrapps
 * their `StaticSymbol`s produced by the `@angular/compiler`.
 *
 * @export
 * @class DirectiveSymbol
 * @extends {Symbol}
 */
var DirectiveSymbol = /** @class */ (function (_super) {
    __extends(DirectiveSymbol, _super);
    /**
     * Creates an instance of DirectiveSymbol.
     *
     * @param {Program} program
     * @param {StaticSymbol} symbol
     * @param {CompileMetadataResolver} metadataResolver
     * @param {DirectiveNormalizer} directiveNormalizer
     * @param {DirectiveResolver} resolver
     * @param {StaticReflector} reflector
     * @param {ResourceResolver} resourceResolver
     * @param {ContextSymbols} projectSymbols
     *
     * @memberOf DirectiveSymbol
     */
    function DirectiveSymbol(program, symbol, metadataResolver, directiveNormalizer, resolver, reflector, resourceResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.metadataResolver = metadataResolver;
        _this.directiveNormalizer = directiveNormalizer;
        _this.resolver = resolver;
        _this.reflector = reflector;
        _this.resourceResolver = resourceResolver;
        _this.projectSymbols = projectSymbols;
        _this.urlResolver = new UrlResolver();
        return _this;
    }
    /**
     * Returns the non-resolved metadata for given directive.
     * If it is a component, this means that the external templates
     * and styles won't be read from the drive. Also, the paths to
     * external metadata won't be resolved.
     *
     * @returns {CompileDirectiveMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getNonResolvedMetadata = function () {
        var data = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
        if (data) {
            return data.metadata;
        }
        return null;
    };
    // TODO: use the normalizer's cache in order to prevent repetative I/O operations
    /**
     * Returns the normalized and resolved metadata for given directive or component.
     * For components, all the external templates and styles will be read and
     * set as values of the returned `CompileTemplateMetadata` properties.
     *
     * @returns {CompileTemplateMetadata}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getResolvedMetadata = function () {
        var _this = this;
        var metadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
        var componentType = resolveForwardRef(this.symbol);
        if (!metadata) {
            return null;
        }
        var componentUrl = this.reflector.componentModuleUrl(componentType);
        var templateMetadata = metadata.metadata.template;
        // Required because otherwise the normalizer gets confused.
        if (!templateMetadata) {
            return null;
        }
        if (!templateMetadata.template && templateMetadata.templateUrl) {
            templateMetadata.templateUrl = this.urlResolver.resolve(componentUrl, templateMetadata.templateUrl);
            templateMetadata.template = this.resourceResolver.getSync(templateMetadata.templateUrl);
        }
        if (templateMetadata.styleUrls.length) {
            templateMetadata.styleUrls = templateMetadata.styleUrls.map(function (s) { return _this.urlResolver.resolve(componentUrl, s); });
            templateMetadata.styles = templateMetadata.styles.concat(templateMetadata.styleUrls.map(function (s) { return _this.resourceResolver.getSync(s); }));
        }
        var module = this.getModule();
        if (!module) {
            return null;
        }
        var config = Object.assign({}, templateMetadata, {
            ngModuleType: module.type.reference,
            moduleUrl: componentUrl,
            templateUrl: null,
            styleUrls: null,
            componentType: componentType
        });
        var currentMetadata = this.directiveNormalizer.normalizeTemplate(config);
        currentMetadata.template = templateMetadata.template;
        currentMetadata.templateUrl = templateMetadata.templateUrl;
        currentMetadata.styles = templateMetadata.styles;
        currentMetadata.styleUrls = templateMetadata.styleUrls;
        return currentMetadata;
    };
    /**
     * Returns the module where the given directive has been declared.
     *
     * @returns {(CompileNgModuleMetadata | undefined)}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getModule = function () {
        return this.projectSymbols.getAnalyzedModules().ngModuleByPipeOrDirective.get(this.symbol);
    };
    /**
     * Returns the ASTs of all styles of the target directive.
     *
     * @returns {CssAst[]}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getStyleAsts = function () {
        var metadata = this.getResolvedMetadata();
        if (metadata) {
            return metadata.styles.map(function (s) { return parseCss(s); });
        }
        return null;
    };
    /**
     * Returns the context into which the template of given
     * component is going to be compiled.
     *
     * @returns {DirectiveContext}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getDirectiveContext = function () {
        var _this = this;
        var analyzedModules = this.projectSymbols.getAnalyzedModules();
        var ngModule = analyzedModules.ngModuleByPipeOrDirective.get(this.symbol);
        if (!ngModule) {
            throw new Error('Cannot find module associated with the directive ' + this.symbol.name);
        }
        var resolvedDirectives = ngModule.transitiveModule.directives.map(function (d) {
            return _this.metadataResolver.getNonNormalizedDirectiveMetadata(d.reference);
        });
        // TypeScript doesn't handle well filtering & strictNull
        var tempDirectives = resolvedDirectives.map(function (d) {
            if (d) {
                return d.metadata.toSummary();
            }
            else {
                return null;
            }
        });
        var directives = [];
        for (var i = 0; i < tempDirectives.length; i += 1) {
            var dir = tempDirectives[i];
            if (dir) {
                directives.push(dir);
            }
        }
        var pipes = ngModule.transitiveModule.pipes.map(function (p) {
            return _this.metadataResolver.getOrLoadPipeMetadata(p.reference).toSummary();
        });
        var schemas = ngModule.schemas;
        return {
            pipes: pipes,
            directives: directives,
            schemas: schemas
        };
    };
    /**
     * Returns the compiled template of the target component.
     *
     * @returns {TemplateAstResult}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.getTemplateAst = function () {
        var result;
        try {
            var resolvedMetadata = this.metadataResolver.getNonNormalizedDirectiveMetadata(this.symbol);
            var dirMetadata = this.getResolvedMetadata();
            if (dirMetadata) {
                var source = dirMetadata.template;
                if (!source) {
                    result = { errors: [{ message: 'Cannot find template for the directive' }] };
                }
                else {
                    var metadata = resolvedMetadata && resolvedMetadata.metadata;
                    if (metadata) {
                        var rawHtmlParser = new HtmlParser();
                        var htmlParser = new I18NHtmlParser(rawHtmlParser);
                        var expressionParser = new Parser(new Lexer());
                        var parser = void 0;
                        parser = new TemplateParser(new CompilerConfig(), this.reflector, expressionParser, new DomElementSchemaRegistry(), htmlParser, {
                            log: function () {
                                return null;
                            },
                            warn: function () {
                                return null;
                            }
                        }, []);
                        var htmlResult = htmlParser.parse(source, '');
                        var _a = this.getDirectiveContext(), directives = _a.directives, pipes = _a.pipes, schemas = _a.schemas;
                        var parseResult = parser.tryParseHtml(htmlResult, metadata, directives, pipes, schemas);
                        result = {
                            templateAst: parseResult.templateAst,
                            parseErrors: parseResult.errors,
                            errors: []
                        };
                    }
                    else {
                        result = { errors: [{ message: 'Cannot find metadata for the directive' }] };
                    }
                }
            }
            else {
                result = { errors: [{ message: 'Cannot find metadata for the directive' }] };
            }
        }
        catch (e) {
            result = { errors: [{ message: e.message }] };
        }
        return result;
    };
    DirectiveSymbol.prototype.getDependencies = function () {
        var _this = this;
        var summary = this.metadataResolver.getInjectableSummary(this.symbol);
        if (!summary) {
            return [];
        }
        else {
            return (summary.type.diDeps || []).map(function (d) {
                var token = d.token;
                if (d.token) {
                    if (d.token.identifier) {
                        token = d.token.identifier.reference;
                    }
                }
                var meta = new ProviderMeta(token, { useClass: d.value });
                return new ProviderSymbol(_this._program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
            });
        }
    };
    DirectiveSymbol.prototype.getProviders = function () {
        var _this = this;
        var meta = this.getNonResolvedMetadata();
        if (meta) {
            return (meta.providers || []).map(function (d) {
                return new ProviderSymbol(_this._program, d, _this.metadataResolver);
            });
        }
        return [];
    };
    DirectiveSymbol.prototype.getViewProviders = function () {
        var _this = this;
        var meta = this.getNonResolvedMetadata();
        if (meta) {
            return (meta.viewProviders || []).map(function (d) {
                return new ProviderSymbol(_this._program, d, _this.metadataResolver);
            });
        }
        else {
            return [];
        }
    };
    /**
     * Returns if the target directive is a component.
     *
     * @returns {boolean}
     *
     * @memberOf DirectiveSymbol
     */
    DirectiveSymbol.prototype.isComponent = function () {
        var meta = this.getResolvedMetadata();
        if (meta) {
            return !!meta.template || !!meta.templateUrl;
        }
        else {
            return false;
        }
    };
    return DirectiveSymbol;
}(Symbol));
export { DirectiveSymbol };
//# sourceMappingURL=directive-symbol.js.map