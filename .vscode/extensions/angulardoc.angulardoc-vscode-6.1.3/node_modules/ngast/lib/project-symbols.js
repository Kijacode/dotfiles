import { ViewEncapsulation, ɵConsole } from '@angular/core';
import { CompileMetadataResolver, NgModuleResolver, DirectiveResolver, DirectiveNormalizer, HtmlParser, CompilerConfig, PipeResolver, AotSummaryResolver, DomElementSchemaRegistry, StaticSymbolResolver, StaticSymbolCache, StaticReflector, createOfflineCompileUrlResolver, analyzeNgModules, GeneratedFile } from '@angular/compiler';
import { MetadataCollector, readConfiguration } from '@angular/compiler-cli';
import { createCompilerHost, createProgram } from '@angular/compiler-cli/ngtools2';
import { PipeSymbol } from './pipe-symbol';
import { DirectiveSymbol } from './directive-symbol';
import { ModuleSymbol } from './module-symbol';
import { TsCompilerAotCompilerTypeCheckHostAdapter } from '@angular/compiler-cli/src/transformers/compiler_host';
/**
 * Creates a proxy which provides us access to the symbols
 * defined in given context (could be lazy loaded module or the root module).
 *
 * @export
 * @class ProjectSymbols
 */
var ProjectSymbols = /** @class */ (function () {
    /**
     * Creates an instance of ProjectSymbols.
     *
     * @param {ts.Program} program
     * @param {ResourceResolver} resourceResolver
     *
     * @memberOf ProjectSymbols
     */
    function ProjectSymbols(tsconfigPath, resourceResolver, errorReporter) {
        this.tsconfigPath = tsconfigPath;
        this.resourceResolver = resourceResolver;
        this.errorReporter = errorReporter;
        var config = readConfiguration(this.tsconfigPath);
        this.options = config.options;
        this.compilerHost = createCompilerHost({ options: config.options });
        // Replace all `\` with a forward slash to align with typescript's `normalizePath`.
        // On Windows, different slashes cause errors while trying to compare module symbols
        var rootNames = config.rootNames.map(function (rootName) { return rootName.replace(/\\/g, '/'); });
        this.program = createProgram({ rootNames: rootNames, options: config.options, host: this.compilerHost });
        this.init();
        // this.clearCaches();
    }
    /**
     * Returns the metadata associated to this module.
     *
     * @returns {ModuleSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getModules = function () {
        var _this = this;
        var resultMap = new Map();
        this.getAnalyzedModules().ngModules.forEach(function (m, s) {
            resultMap.set(m.type.reference, m);
        });
        var result = [];
        resultMap.forEach(function (v) {
            return result.push(new ModuleSymbol(_this.program.getTsProgram(), v.type.reference, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.pipeResolver, _this.reflector, _this.resourceResolver, _this));
        });
        return result;
    };
    /**
     * Returns all the directives available in the context.
     *
     * @returns {DirectiveSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getDirectives = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (symbol) { return _this.metadataResolver.isDirective(symbol); })
            .map(function (symbol) {
            return new DirectiveSymbol(_this.program.getTsProgram(), symbol, _this.metadataResolver, _this.directiveNormalizer, _this.directiveResolver, _this.reflector, _this.resourceResolver, _this);
        });
    };
    /**
     * Returns all the pipes available in this module.
     *
     * @returns {PipeSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getPipes = function () {
        var _this = this;
        return this.extractProgramSymbols()
            .filter(function (v) { return _this.metadataResolver.isPipe(v); })
            .map(function (p) { return new PipeSymbol(_this.program.getTsProgram(), p, _this.pipeResolver, _this.metadataResolver, _this); });
    };
    /**
     * Returns all the providers available in this module.
     *
     * @returns {ProviderSymbol[]}
     *
     * @memberOf ProjectSymbols
     */
    ProjectSymbols.prototype.getProviders = function () {
        var resultSet = new Map();
        this.getModules().forEach(function (m) {
            m.getProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
        });
        this.getDirectives().forEach(function (d) {
            d.getProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
            d.getViewProviders().forEach(function (p) { return resultSet.set(p.getMetadata(), p); });
        });
        var finalResult = [];
        resultSet.forEach(function (v) { return finalResult.push(v); });
        return finalResult;
    };
    /**
     * Returns directive based on `ClassDeclaration` node and a filename.
     *
     * @param {ts.ClassDeclaration} declaration
     * @param {string} fileName
     *
     * @memberOf DirectiveSymbol
     */
    ProjectSymbols.prototype.getDirectiveFromNode = function (declaration, fileName) {
        var sourceFile = this.program.getTsProgram().getSourceFile(fileName);
        if (!sourceFile) {
            throw new Error("Cannot get the program's source file");
        }
        var identifier = declaration.name;
        if (identifier) {
            return new DirectiveSymbol(this.program.getTsProgram(), this.reflector.getStaticSymbol(sourceFile.fileName, identifier.text), this.metadataResolver, this.directiveNormalizer, this.directiveResolver, this.reflector, this.resourceResolver, this);
        }
        else {
            return null;
        }
    };
    /** @internal */
    ProjectSymbols.prototype.getAnalyzedModules = function () {
        var analyzedModules = this.analyzedModules;
        if (!analyzedModules) {
            var analyzeHost = {
                isSourceFile: function (filePath) {
                    return true;
                }
            };
            analyzedModules = this.analyzedModules = analyzeNgModules(this.program.getTsProgram().getRootFileNames(), analyzeHost, this.staticSymbolResolver, this.metadataResolver);
        }
        return analyzedModules;
    };
    ProjectSymbols.prototype.extractProgramSymbols = function () {
        var _this = this;
        return [].concat.apply([], this.program
            .getTsProgram()
            .getSourceFiles()
            .map(function (f) { return _this.staticSymbolResolver.getSymbolsOf(f.fileName); }));
    };
    // private clearCaches() {
    //   this.metadataResolver.clearCache();
    //   this.directiveNormalizer.clearCache();
    // }
    ProjectSymbols.prototype.init = function () {
        var staticSymbolCache = new StaticSymbolCache();
        var summaryResolver = new AotSummaryResolver({
            loadSummary: function (filePath) {
                return '';
            },
            isSourceFile: function (sourceFilePath) {
                return true;
            },
            toSummaryFileName: function (host) {
                return '';
            },
            fromSummaryFileName: function (host) {
                return '';
            }
        }, staticSymbolCache);
        var parser = new HtmlParser();
        var config = new CompilerConfig({
            defaultEncapsulation: ViewEncapsulation.Emulated,
            useJit: false
        });
        var defaultDir = this.program.getTsProgram().getCurrentDirectory();
        this.options.baseUrl = this.options.baseUrl || defaultDir;
        this.options.basePath = this.options.basePath || defaultDir;
        this.options.genDir = this.options.genDir || defaultDir;
        this.staticResolverHost = new TsCompilerAotCompilerTypeCheckHostAdapter(this.program.getTsProgram().getRootFileNames(), this.options, this.compilerHost, new MetadataCollector(), {
            generateFile: function (genFileName, baseFileName) { return new GeneratedFile('', '', ''); },
            findGeneratedFileNames: function (fileName) { return []; }
        });
        this.staticSymbolResolver = new StaticSymbolResolver(this.staticResolverHost, staticSymbolCache, summaryResolver, this.errorReporter);
        this.summaryResolver = new AotSummaryResolver(this.staticResolverHost, staticSymbolCache);
        this.reflector = new StaticReflector(this.summaryResolver, this.staticSymbolResolver, [], [], this.errorReporter);
        var ngModuleResolver = new NgModuleResolver(this.reflector);
        this.directiveResolver = new DirectiveResolver(this.reflector);
        this.pipeResolver = new PipeResolver(this.reflector);
        this.urlResolver = createOfflineCompileUrlResolver();
        this.directiveNormalizer = new DirectiveNormalizer(this.resourceResolver, this.urlResolver, parser, config);
        this.metadataResolver = new CompileMetadataResolver(new CompilerConfig(), parser, ngModuleResolver, this.directiveResolver, this.pipeResolver, summaryResolver, new DomElementSchemaRegistry(), this.directiveNormalizer, new ɵConsole(), staticSymbolCache, this.reflector);
    };
    return ProjectSymbols;
}());
export { ProjectSymbols };
//# sourceMappingURL=project-symbols.js.map