var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { resolveForwardRef } from '@angular/core';
import { ProviderMeta } from '@angular/compiler';
import { Symbol } from './symbol';
import { ProviderSymbol } from './provider-symbol';
/**
 * A wrapper around the pipe symbol.
 *
 * @export
 * @class PipeSymbol
 * @extends {Symbol}
 */
var PipeSymbol = /** @class */ (function (_super) {
    __extends(PipeSymbol, _super);
    /**
     * Creates an instance of PipeSymbol.
     *
     * @param {Program} program
     * @param {StaticSymbol} symbol
     * @param {PipeResolver} resolver
     * @param {ContextSymbols} projectSymbols
     *
     * @memberOf PipeSymbol
     */
    function PipeSymbol(program, symbol, resolver, metadataResolver, projectSymbols) {
        var _this = _super.call(this, program, symbol) || this;
        _this.resolver = resolver;
        _this.metadataResolver = metadataResolver;
        _this.projectSymbols = projectSymbols;
        return _this;
    }
    /**
     * Returns the module where the wrapped pipe was defined.
     *
     * @returns {(CompileNgModuleMetadata | undefined)}
     *
     * @memberOf PipeSymbol
     */
    PipeSymbol.prototype.getModule = function () {
        return this.projectSymbols.getAnalyzedModules().ngModuleByPipeOrDirective.get(this.symbol);
    };
    /**
     * Returns the pipe metadata.
     *
     * @returns {Pipe}
     *
     * @memberOf PipeSymbol
     */
    PipeSymbol.prototype.getMetadata = function () {
        return this.resolver.resolve(resolveForwardRef(this.symbol));
    };
    PipeSymbol.prototype.getDependencies = function () {
        var _this = this;
        var summary = this.metadataResolver.getInjectableSummary(this.symbol);
        if (!summary) {
            return [];
        }
        else {
            return (summary.type.diDeps || []).map(function (d) {
                var token = d.token;
                if (d.token) {
                    if (d.token.identifier) {
                        token = d.token.identifier.reference;
                    }
                }
                var meta = new ProviderMeta(token, { useClass: d.value });
                return new ProviderSymbol(_this._program, _this.metadataResolver.getProviderMetadata(meta), _this.metadataResolver);
            });
        }
    };
    return PipeSymbol;
}(Symbol));
export { PipeSymbol };
//# sourceMappingURL=pipe-symbol.js.map