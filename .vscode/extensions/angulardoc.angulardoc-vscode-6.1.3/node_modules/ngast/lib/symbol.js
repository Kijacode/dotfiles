import * as ts from 'typescript';
/**
 * Base class which provides primitive for the DirectiveSymbol and
 * PipeSymbol. It contains some functionality common between these classes.
 *
 * @export
 * @class Symbol
 */
var Symbol = /** @class */ (function () {
    /**
     * Creates an instance of Symbol.
     *
     * @param {ts.Program} _program
     * @param {StaticSymbol} _symbol
     *
     * @memberOf Symbol
     */
    function Symbol(_program, _symbol) {
        this._program = _program;
        this._symbol = _symbol;
    }
    /**
     * Gets the ts.node which corresponds to the controller of the DirectiveSymbol
     * or the implementation of the pipe.
     *
     * @returns {(ts.ClassDeclaration | undefined)}
     *
     * @memberOf Symbol
     */
    Symbol.prototype.getNode = function () {
        var _this = this;
        var program = this._program.getSourceFile(this._symbol.filePath);
        var findNode = function (node) {
            if (node.kind === ts.SyntaxKind.ClassDeclaration &&
                (node.name || { text: undefined }).text === _this._symbol.name) {
                return node;
            }
            else {
                return ts.forEachChild(node, findNode);
            }
        };
        return findNode(program);
    };
    Object.defineProperty(Symbol.prototype, "symbol", {
        /**
         * The wrapped `StaticSymbol` from `@angular/compiler`.
         *
         * @readonly
         *
         * @memberOf Symbol
         */
        get: function () {
            return this._symbol;
        },
        enumerable: true,
        configurable: true
    });
    return Symbol;
}());
export { Symbol };
//# sourceMappingURL=symbol.js.map